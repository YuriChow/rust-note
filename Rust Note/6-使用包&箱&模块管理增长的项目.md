目前我们写的程序都是在单一文件单一模块内的，当项目增长，你可以 通过将代码分成多个模块 然后 是多个文件 来组织代码。一个包能够包含多个 ***binary crate(二进制箱)*** 和 一个可选的 ***library crate(库箱)***。并且，对于非常大的项目，***Rust*** 还提供了工作区，在 [[12-更多关于Cargo和Crates.io的内容#^Cargo-Workspaces]] 中我们会讲。   
一个相关的概念就是 ***Scope(域)***：一个代码写于其中的嵌套的上下文，拥有一组被定义为 “in scope” 的名字，当读、写、编译代码时，程序和编译器需要知道在一个特定位置的名字是一个变量、函数、结构体、枚举、模块、常数 或是 其他什么 item，和这个项目的含义。你可以创建域并且改变哪些名字是在域内哪些是在域外。你不能在同一个域中拥有两个相同名字的项目，有工具可以解决命名冲突。   
***Rust*** 有一些列特性，允许你管理你代码的结构，包括：哪些细节是被暴露的，哪些细节是私有的，和你程序中每个域中都使用了什么名字。这些特性有时一起被称作 ***module system(模块系统)***，包含：
- ***Packages(包)***：一个 Cargo 特性，让你构建、测试和分享箱
- ***Crates(箱)***：一个模块树，生成一个 库 或者 可执行文件
- ***Modules(模块) 和 `use`***：让你控制 组织、域、和路径的私密性  
- ***Paths(路径)***：命名一个 item 的方法，例如一个结构体、函数或模块


# Packages(包) 和 Crates(箱)
1. 一个 包 是一个或多个 提供一组功能的箱。一个包包含一个 *Cargo.toml* 文件来描述如何构建这些箱。
2. 一个 箱 可以是一个 二进制箱 或者 一个库箱。二进制箱是一个程序 你可以将其编译成一个可执行文件，如命令行文件或者一个服务器。必须包含 `main` 函数，目前我们创建的都是二进制箱。库箱 没有 `main` 函数，不可以被编译成可执行文件，它定义了 打算要在多个项目间分享的 一些功能。
3. ***crate root(箱根)*** 是一个源文件，***Rust*** 编译器从中启动并组成你的箱的根模块 。我们会在 [[6-使用包&箱&模块管理增长的项目#^Defining-Modules-to-Control-Scope-and-Privacy]] 更深入讲解模块。
4. 多个规则决定一个 包 可以包含什么。**一个 包 可以包含至多一个 库箱，还可以包含任意数量的二进制箱。但是必须至少包含一个箱(不论是库 还是 二进制)**。
5. 当我们运行命令 `cargo new my-project`。的时候，Cargo 创建了一个 *Cargo.toml* 文件，给了我们一个 包。观察 *Cargo.toml*，其中并没有提到 *src/main.rs* 因为 ***Rust*** 遵循惯例，将其视为和包同名的二进制箱的 crate root。同样的，Cargo 知道如果包地址包含 *src/lib.rs*，这个包就包含一个和包同名的 库箱，并且 *src/lib.rs* 就是 crate root。Cargo 将箱根文件传入 rustc 来构建 库 或 二进制文件。这里，我们有了一个只包含 *src/main.rs* 的包，这意味着它只包含一个二进制箱，名字叫做 my-project。如果一个包包含 *src/main.rs* 和 *src/lib.rs*，它有两个箱：一个二进制和一个库，都是和 package 同名。**一个包可以有多个二进制箱，通过将文件放到** *src/bin/* **文件夹中，每一个文件都将是一个独立的二进制箱。**
6. 一个箱将会将相关的功能收集到一起，到一个 scope 中，这样可以方便的在多 project 间分享。
7. **将一个箱的功能限制在它自己的域中避免了潜在的命名冲突**。如 我们自己创建了一个 `struct Rng`，并不会产生冲突，如果直接调用 `Rng` 就是我们自己创建的，如果是 `rand::Rng` 就是访问 `rand` 箱中的 `Rng` 特性。


# 定义模块来控制域和私密性

^Defining-Modules-to-Control-Scope-and-Privacy

## 模块快速参考
这节讲述了模块、路径、`use` 关键字和 `pub` 关键字如何在编译器中工作，和绝大多数开发者如何组织他们的代码。我们将介绍这些规则中的每一个，但这是一个很好的地方，可以在将来提醒我们模块是如何工作的，以下例子在二进制箱 `backyard`(*Rust/backyard/*) 内：
- **从 crate root 开始**：当编译一个箱时，编译器首先看的时箱根文件(通常是 *src/lib.rs* - 对于库箱 或者 *src/main.rs* - 对于二进制箱)。
- **声明模块**：在箱根文件，你可以声明一个新的模块和它的名字，例如 “garden”，使用 `mod garden;`。编译器将会 在这些位置寻找 模块中的代码：
   - 行内，紧跟着 `mod garden`，在替换了 `;` 的 `{}` 中
   - 在文件 *src/garden.rs* 中
   - 在文件 *src/garden/mod.rs* 中
- **声明** ***sub-modules(子模块)***：在任何 除了箱根的 将被编译为箱的一部分的文件中(例如，*src/garden.rs*)，你可以声明子模块(例如，`mod vegetables;`)。编译器 将在以父模块命名的目录中 的这些位置 查找 子模块中的代码：
   - 行内，紧跟着 `mod vegetables`，在替换了 `;` 的 `{}` 中
   - 在文件 *src/garden/vegetables.rs* 中
   - 在文件 *src/garden/vegetables/mod.rs* 中
- **模块中代码的路径**：一旦一个模块被编译作为你的箱的一部分，你可以从这个箱的任何其他位置通过使用路径 访问那个模块中的代码(例如，在 garden vegetables 模块中的一个 `Asparagus` 类型) 
- **私有 vs 公有**：模块中的代码对于它的父模块 **默认是私有的**。为了将模块声明为公有，使用 `pub mod` 声明代替 `mod`。通过在声明前增加 `pub` 来使**公有模块**中的项目也公有。
- **使用 `use` 关键字**：在一个域内，`use` 关键字创建了一个 item 的捷径来减少长路径的重复。在任意可以访问 `crate::graden::vegetables::Asparagus` 的域中，通过 `use crate::garden::vegetables::Asparagus;` 你可以创建一个捷径，之后你住需要使用 `Asparagus` 就可以在域中使用那个类型了。   

## 将相关代码分组到模块
1. 模块 让我们 在一个箱中 将代码组织成组，以便阅读和复用。
2. 通过 `mod` 关键字 创建模块：`mod mod_name {// module body}`。模块是可以嵌套的，既模块(体)中还可以包含模块。模块中还可以包含其他项目，如：**stuct, enums, constants, traits, functions**。
3. **模块同时控制 item 的私密性**，既 一个项目可以被外部访问(***public***) 或者 只是一个内部实现细节，不能被外部所用(***private***)。
4. 通过使用模块，我们可以把相关的定义组织在一起，并用命名来表示为什么他们是相关的。这样使用这个代码的程序员会更容易找到他们需要的代码，并且也更容易知道新增代码时在放在哪里。
5. 之前我们提到了 *src/main.rs* 和 *src/lib.rs* 被称为 箱根。这个名字的原因是：这两个文件(二者之一)的内容，在 箱的模块结构的根部 形成了一个名为 crate 的模块，aka ***module tree(模块树)***：  
   ```
   crate
     └── front_of_house
           ├── hosting
           │      ├── add_to_waitlist
           │      └── seat_at_table
           └── serving
                  ├── take_order
                  ├── serve_order
                  └── take_payment
   ``` 
   这个 模块树 展示了模块树是如何嵌套的，以及模块之间的关系。注意，整个模块树的根模块是一个隐式的模块，名为 crate。


# 访问一个模块树中的项目的路径

^Paths-for-Referring-to-an-Item-in-the-Module-Tree

为了告知 ***Rust*** 在哪去寻找一个模块树中的 项目。我们使用路径的方式与导航文件系统时使用路径的方式相同，如果我们调用一个函数，需要知道它的 path - 路径，可以有两种形式：
- **绝对路径**，从箱根开始，使用 箱名(对于外部箱中的代码) 或 crate(对于当前箱中的代码)，如 `crate::front_of_house::hosting::add_to_waitlist()`，同一个箱让我们可以从 `crate` 开始绝对路径
- **相对路径**，从当前模块开始，并且使用 `self`、`super` 或者一个当前模块中的标识符，同一个箱内调用：`front_of_house::hosting::add_to_waitlist()`，从同级的模块开始调用，如果一个**函数**和 `front_of_house` 同级，暨这个函数和 `front_of_house` 在同一个域中，那么这个函数中使用 `front_of_house` 中项目的相对路径以 `front_of_house` 开始。

两种路径都跟随着一个或更多用 `::` 分隔用的标识符。
1. 使用绝对路径还是相对路径取决于项目(实际上，第二种情况更加常见，因此**默认使用绝对路径比较好**)：   
   1. 如果 同时移动 调用代码 和 被调用模块代码，则相对路径无需改变，但绝对路径需要改变；   
   2. 如果 只移动调用代码，不移动被调用模块代码，则绝对路径无需改变，但相对路径需要改变；   
2. **模块** 不仅可以用来管理代码，还定义了 ***Rust*** 的 ***privacy boundary (访问界限)***，封装了实现的细节让外部代码无法 了解、调用 或 依赖。所以，如果你希望设定一个项目(如函数、结构体)为私有的，就将它放到模块中。
3. ***Rust*** **中所有的项目都是默认 private 的**。父模块中的项目不能使用子模块中的 private 项目，但是子模块中的项目可以使用 其祖先模块中的项目。原因是，子模块隐藏了自己的细节，但是它自己本身在祖先模块中，因此能看见其中的上下文。
4. **小结**：模块 `mod` 组成了访问界限，对于 **一个模块域内的项目** 来说它：
   1. 对于域外(不包括内部嵌套的域)的模块和项目，能访问到 这个模块 的 **父模块能够访问到的模块和项目(递归来说，父模块还可以访问父模块的父模块……)**
   2. 对于域内(包括嵌套的域)模块和项目，能访问到 这个模块 的 **直接子模块、直接项目 和 有 `pub` 关键字标识的嵌套子模块&项目**，这里的**直接**指没有在其他的子模块内。
   3. `struct`：如果**私有的结构体**能够被访问到，那么它的字段一定能被访问到。但是，如果**私有的结构体**无法访问到，通过 `pub struct` 才能访问到时，如果不单独给字段增加 `pub` 关键字，那么字段仍是私有的，这倒很像模块。
5. 由小结可知，在绝对路径中：`...::father::xxx::son::...` 中，如果我们的调用位置发生在 `xxx` 的域中，则后面第一个路径项目(包括模块)，此例中即为 `son` 是一定可以访问的，至于之后的项目需要看是否有 `pub` 标识。
6. 由小结可知定义在 *main.rs* 中的，没有在任何 `mod` 下的 `struct` 中的内容对于文件中的域都是 可访问的 的。

## 使用 `pub` 关键字暴露路径
***Rust*** 通过 访问界限 隐藏实现细节，让我们知道什么是在不破坏外部代码的条件下可以修改的。可以通过 `pub` 关键字来暴露 内部(`pub` 的)部分。`pub` 标识的模块，并不会使其内容公开，模块的 `pub` 标识只是让其祖先模块中的代码能够访问它。如果要使用其中的内容，则被使用的内容仍需要 `pub` 标识。   
如果你计划分享你的库箱，这样其他项目能够使用你的代码，你的公有 API 是你和使用者关于如何于你的代码交互的契约。在管理对公有 API 的更改以使人们更容易依赖你的箱 的方面，有许多考虑因素，如果你感兴趣，访问 [The Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)。

## 使用 `super` 开始相对路径
我们还可以在开头使用 `super` 构建**以父模块开始的相对路径**。类似于文件系统中的 `..`。而同级可以使用 `self` 开始，但是同级的项目、模块可以忽略 `self` 直接以项目/模块名开始相对路径即可。

## 使结构体和枚举变为公有
我们还可以使用 `pub` 来将结构体和枚举声明为公有。但是有一点额外的细节。
1. 如果我们在结构体定义前使用 `pub`，我们使结构体公有了，但是结构体的字段仍然是私有的。
2. 如果 `struct` 有私有的字段，则需要提供一个 公开 的关联函数来获得实例，惯例上命名为 `new`。如果没有，我们没有办法正常创建一个实例，因为我们访问不到 私有字段，也无法为其初始化赋值。
3. 相反的是，如果我们 `pub enum`，**其中所有的变体都是公开的**，我们不需要单独设置，就可以访问。因为 枚举 中的变体(也就是变量) 设定成私有的很影响使用，没有什么意义，而每一个都加 pub 又很多余，因此 ***Rust*** 将其设置为 默认公开 的。


# 使用 `use` 将路径导入域
看起来我们写的路径来调用函数长的太不方便了，幸运的是，我们可以使用 `use` 关键字来创建路径的简写。通过 `use` 关键字，我们可以将一个路径引入到一个域中，然后像调用本地项目一样调用这个项目。效果类似于将 path 指引的项目完全复制了一份到这个域中(其实只是增加了链接)。   
1. 注意 `use` 只是为 `use` 发生的这一个域创建了捷径，如下代码会编译错误：
```rust
mod front_of_house {
   mod hosting {
      pub fn add_to_waitlist(){}
   }
}
use crate::front_of_house::hosting;
mod customer {
   pub fn eat_at_restaurant() {
      hosting::add_to_waitlist();
      // error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
      // 可以使用相对路径来访问到这个引入
      super::hosting::add_to_waitlist();
   }
}
``` 

## 创建地道的 `use` 路径
1. `use` 的 path 可以一直到需要的函数名，但是并不推荐。地道的做法是 path 到需要使用的函数的父模块，这样调用的时候，由于有 `parent_module::func();` 形式，可以很好的和本地定义的函数进行区分。
2. 另一方面，当使用 `use` 导入结构体、枚举和其他项目，地道的做法是声明全路径，例如：`use std::collections::HashMap;`，这样可以直接使用 `HashMap::new()`。
3. 这种习俗没有什么很强的原因：只是习俗，大伙都习惯了这样读、写 ***Rust*** 代码。但是也有例外，如果导入了两个同名的项目进入域，***Rust*** 是不会允许的，如：`use a::b::c;` 有 `c` 可以访问。`use d::e::c` 还是可以访问 `c`。这时候会产生歧义，路径需要在前一个项目(模块/父模块)截至，这样在使用的时候就可以区分了。或者使用 `as` 改成不同的名字。两者都是常用的。
4. 当然，如果祖先类中的项目，也可以 `use` 到更上层，而避免多次导入。(但是有的语言这样导入了一些用不到的项目，会导致生成文件没必要地变大，***Rust*** 不知道是否会有此影响)。但是并不是地道的用法，因为我们使用 `use` 就是为了简写。

## 使用 `as` 关键字提供新的名字
另一个解决域中同名问题的方法：在导入语句的结尾(`;` 前)，增加 `as` 和类型的一个新本地名或别名。`use xxx::yy::zz as MeaningfullName;` 这时，使用 `MeaningfullName` 来访问 `xxx::yy::zz` 。

## 使用 `pub use` 重导出名
将一个名引入到域中，这个项目名**默认是 private 的**，如果你没有注意到很可能是因为引入通常发生在祖先模块中，子模块可以默认访问到。可以有选择的在最前面增加 `pub` 标识符。`pub use crate::xxx::yyy;` 可以变更为 public。这个技术叫做 ***re-exporting(重导出)***，因为我们在域中导入了项目又使它可以被别的域导入所使用。     
1. **这个技术主要用于，当代码的 内部结构 和 调用代码的开发者如何看待域 之间不同的时候**。如，饭店的比喻，店家考虑的是“前台”“后台”。但是来的顾客不会这样考虑。有了 `pub use`，我们可以用一个**结构**编写代码，但是暴露另一个**结构**，比如本来应该在三层嵌套模块中的一个项目，可以在第一层来暴露，这样编写者和使用者看到的代码结构是不同的。这样是我们的 库 更加规整，易于使用、修改。     
2. 编写项目都是 private 的，其中需要暴露的项目，使用 `pub use` 来暴露，并且可以使用 `pub use ... as ...` 来改变外面的项目可以访问的 名字，并且通过调整重导出的位置，可以以你希望使用者看到的结构来暴露。   
3. 例子可以见 [[12-更多关于Cargo和Crates.io的内容#^Export-a-Convenient-Public-API-with-pub-use]]。

## 使用外部包
1. 导入外部包，***Rust*** 社区成员们编写了很多包在：[**Crates 库**](https://crates.io/) ，导入这些包括以下步骤：   
   1. 在 *Cargo.toml* 文件 `[dependencies]` 节中列举需要导入的包 `crate_name = "crate_version"`
   2. 使用 `use` 将其从它的箱中导入到自己的域中 
2. `std` 库也是一个外部的箱。但是因为和 ***Rust*** 打包在一起了，所以不用修改 *Cargo.toml* 文件，但是对于 `std` 中不在 prelude 中的项目，使用 `use` 导入还是需要的。

## 使用嵌套路径来清理大型 `use` 列表
你 `use` 的东西太多，会导致占用很大的纵向空间，这时候我们需要使用嵌套路径来使导入列表简介，如：`use 从左向右路径的最长共同字符{其余的部分1, 其余的部分2, 其余的部分3}` 如果其余的部分为空，则使用 `self` 代替。如：
```rust
use std::cmp::Ordering;
use std::io;
// 可以简化为： 
use std::{cmp::Ordering, io};
```
```rust
use std::io;
use std::io::Write;
// 可以简化为：
use std::io::{self, Write};
```

## 全局运算符
如果我们想要都导入，可以使用全局运算符 `*` ：`use xxx::yy::*;`。这**一般不是一个好主意**，你不仅不知道导入了什么项目，而且还可能会产生命名冲突，更常用的还是测试的时候图方便，我们会在 [[10-编写自动化测试#^How-to-Write-Tests]] 中讨论。全局运算符有时还作为 prelude 模式的一部分，更多信息查阅：[the standard library documentation](https://doc.rust-lang.org/std/prelude/index.html#other-preludes)。


# 将模块分成不同的文件

^Separating-Modules-into-Different-Files

随着项目的增大你可能希望将代码分成不同的文件以便于导航。
1. 方法：
   1. 将 `{}` 中的**代码 剪切**，将 `{}` 删除，仅留下 `mod mod_name;`
   2. 将 **剪切板 中的代码**(暨 原 `{}` 中的代码)粘贴到名为 *src/mod_name.rs* 的新文件中。
   3. 对于不是箱根下的模块，暨访问不是 `crate::mod_name`，分离成单独的文件时，文件必须要放在 与父模块同名的文件夹 中，暨需要有相同结构的文件夹嵌套。
2. 注意你只需要使用 `mod` 声明一次加载文件内容到你的模块树中，一旦编译器知道文件是项目的一部分(并且通过你放置 `mod` 的位置知道了模块代码是在模块树的哪个位置)，你项目中的其他文件需要用之前讲过的 路径 来访问它。话句话说，不像其他语言，`mod` **不是**一个 “include” 操作。
3. `mod mod_name;` 语法，注意 `mod_name` 后面没有 `{}` 而是一个 `;`，这样 ***Rust*** 知道需要引入文件：*mod_name.rs* 中的代码 作为其 模块体。如果要嵌套，则需要按照 path 类似的系统路径来创建 对应名字的文件夹 和 对应名字对应位置的 `rs` 文件。如果没有记住，改错提示也能帮助修改。
4. **以上讲的都是编译器使用的最地道的文件路径**，但是一个老旧的文件路径还是支持的：
   1. 对于一个箱根下名为 `front_of_house` 的模块，编译器会在以下文件中寻找模块代码
      1. *src/front_of_houst.rs*
      2. *src/front_of_house/mod.rs*(老路径，还支持)
   2. 对于一个 `front_of_house` 的子模块 `hosting`，编译器会在以下文件重寻找模块代码：
      1. *src/front_of_house/hosting.rs*
      2. *src/front_of_house/hosting/mod.rs*(老路径，还支持)
5. 对于新老文件路径，如果同时应用在同一个模块上，会编译器报错。一个项目中，不同模块使用不同的新老路径是允许的，但是除了使人困惑以外有什么必要呢……
6. 对于老文件路径的缺点就是，最后你的项目中会有非常多的 *mod.rs* 文件，当你用编辑器打开时很难分辨。


# 代码
- Rust/my-project/
- Rust/backyard/
- Rust/restaurant/src/lib.rs
- Rust/restaurant_sepfile/src/
