***Pointer(指针)***：一个指针通常指 一个包含一个内存中地址 的变量，这个地址 ***refer to(引用)***，或者说 ***“point at(指向)”*** 其他数据。
1. ***Rust*** 中最常见的一种指针是你在 [[3-理解Ownership(所有权)]] 中见过的 **reference(引用)**，使用 `&` 符号来借用引用指向的变量，除了引用外没有任何其他的能力，因此也没有额外开销，是我们最常用的一类指针。
2. ***Smart pointers(智能指针)***，作为一个数据结构，不仅行为像指针，并且也有额外的元数据和能力。智能指针这个概念不是 ***Rust*** 独有的：智能指针起源于 ***C++*** 并且在其他语言中也存在。在 ***Rust*** 中，标准库中定义的不同的智能指针提供了引用没有的功能。例如：***reference counting smart pointer type(引用计数智能指针类型)***，这个指针允许你 对数据拥有多个 owner，通过计数 owner 的数量，当数量归零的时候，清除数据。
3. 在 ***Rust*** (一个使用 ownership 概念和借用的语言) 中，智能指针和引用间一个额外的不同是：引用是仅借用数据的指针；相反，多数情况下，智能指针 **拥有** 他们指向的数据。
4. 我们已经遇见过一些智能指针了，如：`String` 和 `Vec<T>`，虽然那个时候我们不这样称呼他们。这种类型算作智能指针，是因为他们拥有一些内存，并且允许你操作他，并且他们也有元数据(如 capacity)和一些额外的能力或者担保(例如 `String` 保证了数据一定是合法的 UTF-8)。
5. **智能指针通常使用 结构体 来实现**。智能指针区别于普通结构体的特征是：智能指针实现了 `Deref` 和 `Drop` 特性。`Deref` 特性允许智能指针结构体的一个实例行为像引用一样，这样可以写代码使用 引用 或者 智能指针。`Drop` 特性允许客制化 当实例离开作用域(失效)的时候 运行的代码。接下来会逐步解释为什么这两个特性很重要。
6. 考虑到智能指针是一个很通用的设计模式，在 ***Rust*** 中很常用，我们不会涵盖每种现存的智能指针。很多库都有他们自己的智能指针，我们自己也可以写自己的智能指针。我们仅会介绍标准库中最常见的智能指针：
   1. `Box<T>`：用于在堆内存上分配值
   2. `Rc<T>`：一个引用计数类型，允许多 ownership
   3. `Ref<T>` 和 `RefMut<T>`，通过 `RefCell<T>` 访问，一个类型，它将引用规则 强制在 运行时 而不是 编译时。


# 使用 `Box<T>` 指向堆上数据
最直接的智能指针就是 ***Box(盒)***，类型写作 `Box<T>`。Box 允许在堆上存储数据，而不是在栈上，栈上只留着指向堆上数据的指针。     
Box 没有额外性能开销，除了将数据存在堆上而不是栈上。但是也没有什么额外的能力，常在以下情况下使用：
- 当有一个类型，这个类型的大小在编译时是无法确定的，并且你希望 在一个要求确切值的上下文中使用 一个这个类型的值。
- 当有大量的数据，并且希望转移 ownership，同时保证数据不被复制
- 当希望拥有一个值，并且只关心这个值实现了一个特定的特性，不关心他具体是什么类型。aka，***trait object(特性对象)***。

## 使用一个 `Box<T>` 将数据存在堆上
在开始之前，我们讲一下如何与存储在 `Box<T>` 中的数据进行交互。我们访问 Box 中的数据就像这个数据在栈上一样。和其他数据一样 Box 超出作用域，内存就会被释放，释放发生在 Box(栈) 和他 **指向的数据(堆)**。单独放一个数据到堆上用处不大，因此以下用法不常见。一个 `i32` 的数据就默认地存在栈上才是常见情况。但是有的情况，不使用 Box 是无法定义一些特别的类型的。
```rust
let b = Box::new(5);
println!("b = {}", b);
```

## 使用 Boxes 允许 ***Recursive Type(递归类型)***
编译时，***Rust*** 需要知道一个类型需要多少空间。一个编译时无法知道大小的类型叫做 ***recursive type(递归类型)*** - 一个值拥有一个和自己本身类型相同的字段。由于这种嵌套，值理论上是无限嵌套的，***Rust*** 不知道递归类型到底需要多少空间。然而，Box 有一个已知的大小，因此把 Box 插入到递归类型的定义中，我们就可以定义出、使用递归类型。例如：***cons list*** - 函数式编程语言中常见的数据类型，就是一种常见的递归类型。接下来我们探索 *cons list*，我们的定义除了递归部分都很简单，因此，例子中的概念 在任何你遇见包含递归类型的更复杂的情况时 都将会很有用。
### 关于 ***Cons List(构造列表)*** 的更多信息
***cons list*** 是从 ***Lisp*** 编程语言 和它的 “方言” 中来的。在 ***Lisp*** 中 `cons` (***construct - 构造*** 的简写) 函数 从它的两个实参构建一个新 **对**，两个实参通常是一个单值和另一个对。这些对 嵌套 对 构造了一个列表，这个概念进入了更加通用的函数式编程语言行话：“在 y 上 构建 x”，意思是**通过 把元素 x 放到这个新容器的开头 来构建一个新的容器实例，紧跟着 x 的是 容器 y**。以下示例方便理解：
```lisp
(setf y(cons 1 (cons 2 (cons 3 4))))   
; y 的开头元素是 1，最后一个元素是 (2 3 .4) - 点列表
(setf z(cons 1 (cons 2 (cons 3 nil))))
; z 等价于 (list 1 2 3 4) - 真列表，会隐藏掉最后的 nil 和 . 
```   
1. 每个 cons list 中的项目包含两个元素：当前项目的值 和 下个项目。list 中最后一个项目只包含一个 `Nil` 值且没有下一个项目。一个 cons list 是通过递归调用 `cons` 函数获得的，标记这个递归的 base case(基例) 的规范命名是 `Nil`，注意这和第六章中的 "null" 或者 "nil" 概念不同。   
2. 虽然函数式编程语言经常使用 cons list，但是他在 ***Rust*** 中不是一个常用数据结构，多数情况，`Vec<T>` 都是一个更好的选择。其他的、更复杂的递归数据类型在不同的情况下很有用，但是我们以 cons list 开始，我们可以探索 Box 是如何让我们定义一个递归数据类型。
### 计算一个非递归类型的大小
以前几章创建的 `Message` 枚举为例讨论 ***Rust*** 是如何据决定给一个实例分配多大空间：
```rust
enum Message {
   Quit,
   Move {x: i32, y: i32},
   Write(String),
   ChangeColor(i32, i32, i32),
}
```   
为了决定给一个 `Message` 类型的值分配多大空间，***Rust*** 遍历每一个枚举的变体找出**最占空间的一个**，`Message::Quit` 不需要任何空间，`Message::Move` 需要足够的空间来存储两个 `i32` 值，等等。由于每个变量实际只有一个变体会被使用， `Message` 变量的大部分空间需求都是为了 **存储最大变体** 预留的。因此，***Rust*** 不知道要给递归数据类型分配多少空间，因为为了计算递归类型的大小，***Rust*** 需要知道递归类型的大小，“递归”进去了，算不出来。
### 使用 `Box<T>` 来获得一个拥有已知大小的递归类型
编译器建议：“help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable”。      
在这个建议中，“indirection” 指通过存储指针的方式 修改数据结构 来间接存储数据，而不是直接存储一个数据。因为 `Box<T>` 是一个指针，***Rust*** 总是知道一个 `Box<T>` 需要多少空间：一个指针的大小不随着其指向的数据大小改变。这意味着，我们可以在 `Cons` 的变体中放置一个 `Box<T>` 而不是直接放另一个 `List`。`Box<T>` 将会指向下一个在堆上的 `List` 值，而不是在 `Cons` 变体中。概念上，我们还是有一个 list - 通过 “持有” 其他 lists 来创建的，但是现在的这个实现更像是 紧挨着放置项目，而不是嵌套着放置。   
```rust
enum List {
   Cons(i32, Box<List>),
   Nil,
}
```     
这时候，***Rust*** 很容易算出需求的空间是一个 `i32` 的空间 加上 一个指针的数据，也就可以编译成功了。      
Boxes 只提供间接和堆分配功能，没有像我们之后讲的其他智能指针的其他特别的能力，也没有那些特殊能力带来的额外的性能开销，所以它们在 cons list 这种情况中很有用，间接是我们唯一需要的特性。


# 使用 `Deref` 特性 像常规引用一样对待智能指针

^Implicit-Deref-Coercions-with-Functions-and-Methods

实现 `Deref` 特性允许你客制化 ***dereference operator(解引用算子)*** - `*` (不是乘法或者全局操作符)。通过以 智能指针可以像常规引用一样对待 这种方式来实现 `Deref`，你可以写 操作引用的 代码，并且也可以使用这个代码操作智能指针。   
注意：我们将要构建的类型 `MyBox<T>` 和 `Box<T>` 的一个很大的区别是，我们的版本将不会把它的数据存储到堆上。这个例子我们聚焦于 `Deref`，其他的不那么重要

## 使用解引用操作符跟随指针到达值

^Following-the-Pointer-to-the-Value-with-the-Dereference-Operator

```rust
fn main() {
   let x = 5;
   let y = &x;
   assert_eq!(5, x);
   assert_eq!(5, *y);
}
```
如果我们直接将 `5` 和 `y` 进行比较，那么会编译报错，因为没有实现 `i32` 和 `&i32` 的比较，简单来说 `5` 和 `&5` 是不相等的(或者说不能比较)；

## 像一个引用一样使用 `Box<T>` 
我们可以使用 `Box` 包装一个数据，来代替引用，解引用一样可以操作，就像直接使用引用而不是 `Box` 包装。      
上面的示例代码中，`let y = &x;` 和 `let y = Box::new(x)` 的主要区别是：后者 `y` 是一个指向 `x` 的复制值 的 `Box<T>` 实例，而不是一个指向 `x` 的引用。

## 定义我们自己的智能指针
`Box<T>` 类型最终被定义为一个 拥有一个元素的元组结构体，我们以相同方式定义一个 `MyBox<T>` 类型，并且还实现了 `new` 函数：
```rust
struct MyBox<T>(T);
impl<T> MyBox<T> {
   fn new(x: T) -> MyBox<T> {
      MyBox(x)
   }
}
```   
但是这还不够，因为 ***Rust*** 并不知道如何解引用这个类型的对象，暨 `*` 操作符无法使用，会报错，因为我们还没有为我们的结构体实现 `Deref` 特性。

## 通过实现 `Deref` 特性来像引用一样对待一个类型
实现 `Deref` 特性，需要实现一个名为 `deref` 的函数，这个函数借用 `self`，返回内部数据的一个引用，如下：
```rust    
impl<T> Deref for MyBox<T> {
   type Target = T;
   
   // fn deref(&self) -> &<Self as Deref>::Target { // 根据提示 OK
   fn deref(&self) -> &Self::Target { // 根据 Rust 文档，更简洁 OK
      &self.0
   }
}
```   
1. `type Target = T;` 语法定义了一个关联类型为 `Deref` 特性来使用。关联类型是一种稍微不同的 声明一个泛型的方式，[[17-高级功能]] 会讲。
2. 我们还需要实现一个 `deref(&self) -> &Self::Target {}` 函数，返回的值就是当我们使用 `*` 解引用时希望得到的值的的引用，在幕后，***Rust*** 实际上运行的是 `*(y.deref())`。***Rust*** 将 `*` 替换成 `deref` 方法的调用，然后再一个朴实无华的解引用，这样我们就不需要思考是否我们需要调用 `deref` 方法了。
3. `deref` 之所以返回一个值的引用，并且引用外面还要套括号：`*(y.deref())`，是因为 ownership 系统。如果 `deref` 方法直接返回值而不是引用，值会被移出 `self`，我们在绝大多数情况下使用 `*` 不希望夺走 `MyBox<T>` 内部值的所有权。   
4. 如果没有实现 `Deref` 特性，编译器只能解引用 `&` 引用。
5. 这个 ***Rust*** 特性让我们对这个功能需求写出相同的代码，无论是对待常规引用还是一个实现了 `Deref` 的类。
6. 注意：每次我们使用 `*`，`*` 操作符被替换成了 `deref` 方法，之后调用 **一次** `*` 操作符，因为**这种代替不是无限递归的**，所以最后得到了 `T` 类型的数据。

## 函数和方法的隐式解引用强制多态
***Deref coercion(解引用强制多态)*** 是 ***Rust*** 在函数和方法的实参上 提供的便利，只工作在实现了 `Deref` 特性的类型上，作用是将 **一个类型引用 转化成 另一个类型的引用**。
1. 例如，解引用强制多态可以将 `&String` 转化成 `&str`，因为 `String` 类型实现了 `Deref` 特性，因此它返回 `&str`。解引用强制多态是 当我们传入函数/方法一个与其声明中参数的类型不匹配的引用时 **自动发生的**，一系列 `deref` 方法的调用将我们提供的类型转化成需要的类型。      
2. 解引用强制多态 被增加到 ***Rust*** 中，这样程序员在写函数/方法调用的时候就不需要增加很多明确的引用 `&` 和解引用 `*`，并且还允许我们写更多的可以使用引用或智能指针的代码。   
3. 由于 `MyBox<T>` 实现了 `Deref` 特性，***Rust*** 通过调用 `deref` 方法，可以将 `&MyBox<String>` 转化为 `&String`，而标准库为 `String` 实现了 `Deref`，***Rust*** 再调用 `String` 的 `deref` 方法，返回函数定义要求的实参类型 `&str`。如果没有解引用强制多态，需要 `&(*my_box)[..]`，才能将一个 `MyBox<String>` 值转化成 `&str` 来使用，难读、难写、难理解。  
4. 当实现了 `Deref` 的一个类被卷入计算，***Rust*** 会分析类型，并且多次调用 `Deref::deref`，直到获得了匹配参数类型的引用。`Deref::deref` 需要被插入的次数是在编译时完成计算的，因此利用解引用强制多态没有任何额外的运行时损耗
5. 小结：简言之，`MyBox<T>` 实现了 `Deref`，因此，调用 `deref(&self) -> &Self::Target`，可以把 `&Self` 也就是 `&MyBox<T>` 转化成返回值 `&T` 。如果我们想把 `MyBox<T>` 作为引用操作，通过 `*my_box` 来获得内部值，所以幕后 `*my_box` 实际是 `*(my_box.deref())`。

## 解引用强制多态如何与可变量互动
类似于实现 `Deref` 特性可以覆写针对不可变引用的 `*` 操作符，我们也可以实现 `DerefMut` 特性来覆写针对可变引用的 `*` 操作符。      
***Rust*** 执行 解引用强制多态 当他发现 类型和特性 实现为以下三种情况：
- 从 `&T` 到 `&U` 当 `T: Deref<Target=U>`
- 从 `&mut T` 到 `&mut U` 当 `T: DerefMut<Target=U>`
- 从 `&mut T` 到 `&U` 当 `T: Deref<Target=U>`   

第三种情况更加棘手：***Rust*** 也会将 一个可变引用 强制变为 不可变的另一个。但是反之是不可以的：不可变引用永远不会 强制变为 可变引用。这是由于借用原则，如果有一个可变引用，那么这个可变引用必须是对应数据的唯一一个引用，将可变引用转换为不可变永远不会打破借用规则，而将不可变引用转化为可变引用需要要求这个不可变引用是唯一的引用，但是引用规则不能够保证，因此 ***Rust*** 不能假设不可变转换为可变是可行的。


# 使用 `Drop` 特性 在清扫数据时运行代码
第二个智能指针模式的关键特性是 `Drop`，让我们能够客制化 当一个值离开作用域 会发生什么。我们可以为任何类型实现 `Drop` 特性，并且声明的代码可以用来释放资源(如文件、网络链接)。我们在这里引入是因为当实现一个智能指针的时候， `Drop` 特性种的功能几乎总是会被用到，例如：当一个 `Box<T>` 被 drop，会释放其指向的堆上的内存空间。
1. 在某些语言里，每当使用完成一个智能指针实例，程序员必须调用代码来释放内存或者资源。如果他忘记了，系统可能会超载并且崩溃。在 ***Rust*** 中，你可以声明特定的一段代码来运行无论什么时候一个值离开了作用域，并且，编译器会自动插入这段代码。因此，你不需要担心程序中 清扫代码 放得哪里都是，同时也不会有资源泄漏。为了实现这个，需要类型实现 `Drop` 特性，`Drop` 特性要求实现一个名为 `drop` 方法，此方法以 `&mut self` 为其参数。
2. `Drop` 是被包含进 prelude 的，所以我们不需要导入。实现 `Drop`:
   ```rust
   struct CustomSmartPointer {
      data: String,
   }
   impl Drop for CustomSmartPointer {
      fn drop(&mut self) {
         println!("Dropping CustomSmartPointer with data {}", self.data);
         // 这里仅作为演示，通常，我们应该声明清扫代码，而不是一个输出宏
      }
   }
   ```   
3. 注意：我们不需要明确地调用 `drop` 方法。***Rust*** 在我们的实例离开作用域的时候会自动调用 `drop` 函数。**如果多个变量同时离开作用域，drop 的顺序和他们创建的顺序刚好相反，暨先创建的后离开，后创建的先离开**，可能是因为变量(名)是储存在在栈中的，遵循 ***LIFO***。

## 使用 `std::mem::drop` 来提前 drop 一个值
没有直接的方法来禁用自动 drop 功能。禁用 drop 通常是不需要的；`Drop` 特性的用处就是为了全自动处理 drop 情况。然而，偶尔我们可能希望提前清扫一个值，一个例子是：当使用 操作锁的智能指针 时候，你可能希望强制 `drop` 方法，释放锁，这样同域的其他代码可以获取这个锁。***Rust*** 禁止手动调用 `Drop` 特性的 `drop` 方法(暨实现了 `Drop` 特性得类的变量上的 `drop` 方法)，作为替代的是调用标准库提供的 `std::mem::drop` 函数，如果你希望强制一个值在其域的结尾前提前 drop。
```rust
let c = CustomSmartPointer { data: String::from("some data") };
//c.drop();  // error[E0040]: explicit use of destructor method
drop(c); // std::mem::drop
```   
1. 如果我们手动调用 `drop ` 方法，会编译器报错，“禁止直接调用 `drop` ”，***destructor(析构函数)*** 是一个编程术语，暨清理一个实例的时候运行的函数，与之对应的是 ***constructor(构造函数)*** ，用来创建一个实例。`drop` 函数就是一个析构函数。
2. ***Rust***  禁止我们直接调用 `drop` 方法的原因是 ***Rust*** 始终会在域的结束调用，这会造成 ***double free*** 错误，暨释放同一个值两次。
3. 我们不能关闭 值离开域时自动插入 `drop` 方法，也不能直接调用 `drop` 方法，这时，我们需要 `std::mem::drop` 函数，与 `Deref` 中的 `drop` 方法并不相同，我们通过传入我们希望提前 drop 的变量作为其实参，来使用它。`std::mem::drop` 函数是在 prelude 中，因此不需要引入。
4. 你可以有多种方式来使用实现了 `Drop` 的代码，来使清扫方便、安全：例如，可以使用它来创建自己的内存分配器！
5. 配合着 `Drop` 和 ***Rust*** 的 ***ownership system(所有权系统)***，你无需牢记清垃圾，因为 ***Rust*** 会自动完成，你也无需担心一不小心清扫了正在使用中的变量：所有权系统保证了引用总是有效的，并且保证 `drop` 只在值不再被使用的时候调用一次


# `Rc<T>` 引用计数智能指针
绝大多数情况下，ownership 很清晰：你准确的知道哪个变量拥有一个给定的值。然而，有的时候，一个单一的值可能有多个 owners。例如，在图形数据结构中，多个边界可能指向同一个节点，并且那个节点概念上被所有的指向它的边界拥有，一个节点只有在没有任何边界指向它的时候，才可以被清扫。为了实现 多所有权功能，***Rust*** 有一个类型，称为 `Rc<T>`，暨 ***reference counting*** 的简写。`Rc<T>` 类型跟踪记录了一个值的引用数量 来确定这个值是否还在被使用，如果引用数量为 0，这个值就可以被清扫，因此不会导致任何引用失效。
1. 如果我们希望放置一些数据在堆上 给软件的多个部分 读取，并且编译时我们无法确定是那一部分将会最后用完这个数据，这时我们使用 `Rc<T>` 类型。如果我们知道哪一部分是最后一个用完这个数据的，我们可以直接让这部分作为数据的 owner 就可以了。
2. **注意：`Rc<T>` 仅用于 单线程 情况**。当我们讨论并发的时候 [[14-无畏并发]]，我们会将到如何在多线程应用中使用引用计数。

## 使用 `Rc<T>` 来共享数据
回忆我们使用 `Box<T>` 定义的 cons list(*Rust/box_learn/src/main.rs*)。这次我们创建两个列表共享第三个列表的所有权。将其中 `List` 定义中的 `Box<List>` 修改为 `Rc<List>`，现在每个 `Cons` 变体会持有一个值和一个指向一个 `List` 的 `Rc<T>`。并且我们可以多个变量共享一个变量的所有权，如：
```rust
fn main() {
   use std::rc::Rc;
   let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
   let b = Cons(3, Rc::clone(&a));
   let c = Cons(4, Rc::clone(&a));
}
enum List {
   Cons(i32, Rc<Cons>),
   Nil,
}
```   
1. 当我们 `let b = Cons(3, Rc::clone(&a))` 的时候，不像用 `Box<T>` 实现的一样，会夺走 `a` 的所有权，我们会克隆 `a` 持有的 `Rc<List>`，因此增加引用计数从 1 到 2，并且让 `a` 和 `b` 共享那个 `Rc<List>` 中的数据的所有权。当创建 `c` 的时候，一样，并且引用计数从 2 增加到 3。每次我们调用 `Rc::clone`，`Rc<List>` 中的引用计数器就会增加，并且数据不会被清除直到引用计数降为 0。   
2. 我们也可以调用 `a.clone()` 代替 `Rc::clone(&a)`，但是 ***Rust*** 的**习俗是使用后者**，`Rc::clone` **不会**像大多数实现了 `clone` 的类型一样对所有数据创建深拷贝，只会增加引用计数，不花费很多时间，而深拷贝消耗大量的时间。通过对引用计数智能指针使用 `Rc::clone` 格式的语法，我们可以形象化的区分 **深拷贝类克隆** 和 **增加引用计数类克隆**，当我们查找代码**性能问题**的时候，只需要考虑**深拷贝类克隆**，不需要考虑**增加引用计数类克隆**

## 克隆一个 `Rc<T>` 增加引用计数
1. `Rc::strong_count(&a)` 可以查询 `a` 的引用数量。可以看到 "strong"，这是因为 `Rc<T>` 还有 `weak_count`
2. 我们不需要调用函数来减少引用计数，就像我们调用 `Rc::clone` 来增加引用计数那样：`Drop` 特性的实现当一个 `Rc<T>` 值离开作用域的时候自动减少引用计数。
3. 通过不可变引用，`Rc<T>` 允许你在程序的多个部分间共享数据，仅用于只读。如果它也允许多个可变引用，那么你很可能会违反借用规则：同一内存地址有多个可变引用会导致数据竞争和矛盾。但是可变是一个非常有用的功能，接下来讨论如何实现。


#  `RefCell<T>` 和 内部可变模式
***Interior mutability(内部可变)*** 是 ***Rust*** 中的一个设计模式，允许你修改数据，即使这个数据已经存在不可变引用(暨正常情况会违反引用规则)。为了修改数据，模式在数据结构中使用了 `unsafe` 代码来绕过 ***Rust*** 控制变更和借用的常规规则。我们可以使用 利用了内部可变模式的类型 当我们能够保证 **运行时** 可以遵守借用规则，即使编译器不能够保证。涉及的 `unsafe` 代码被封装在安全的 API 中，并且外部类型依旧是不可变的。类型例如：`RefCell<T>`。

## 使用 `RefCell<T>` 将借用规则强制在运行时
1. 不像 `Rc<T>`，`RefCell<T>` 类型对它包含的数据表现为单个所有权。而 `RefCell<T>` 和 `Box<T>` 的不同是：对于引用和 `Box<T>`，借用规则的不变性是在 **编译时** 强制要求的保证的，而 `RefCell<T>` 这种不变性留到了 **运行时** 保证。暨，如果违反了借用规则，引用和 `Box<T>` 会产生编译时错误，而 `RefCell<T>` 会导致程序 panic 并退出(但是可以正常通过编译)。   
2. 在编译时 检查借用规则的优点是：开发的时候就可以发现错误，并且对于运行时的性能没有任何影响，因为所有分析在编译的时候早就完成了。也因此，**在编译时 检查借用规则 在大多数情况下是最优选择**，因此也是 ***Rust*** 的默认设定。 
3. 在运行时 检查借用规则的优点是：能够允许 某些编译时检查不允许但之后允许的 内存安全场景。像 ***Rust*** 编译器这种静态分析是固有谨慎的。一些代码特性是无法通过代码分析来探测的：最著名的例子就是 ***Halting Problem***。
4. 因为有些分析是不可能的，如果 ***Rust*** 编译器不能保证代码符合所有权规则，他可能会拒绝一个正确的程序，在这方面，他是有些保守的，如果他允许了，那么我们程序员就很难信任 ***Rust*** 做的担保了。然而，如果 ***Rust*** 拒绝了一个正确的程序，会给我们带来不便，但是也没什么灾难发生。
5. 当你确定你的代码 符合借用规则，但是编译器却无法理解和保证这点时，`RefCell<T>` 类型十分有用。类似于 `Rc<T>`，`RefCell<T>` 只是用于单线程情况，并且在被用于多线程上下文的时候会报错，多线程在 [[14-无畏并发]] 会讲。   
6. 回忆一下选用 `Box<T>`、`Rc<T>` 或 `RefCell<T>` 的原因：
   - `Rc<T>` 允许同一数据拥有多个拥有者；其他两个只有单个拥有者。
   - `Box<T>` 允许不可变或者可变借用，在编译时检查；`Rc<T>` 仅允许不可变借用，在编译时检查；`RefCell<T>` 允许不可变或者可变借用，在运行时检查。
   - 因为 `RefCell<T>` 允许在运行时检查的可变引用，你可以改变 `RefCell<T>` 中的值，即使 `RefCell<T>` 是不可变的。

## 内部可变：一个不可变值的可变借用
借用规则的一个结果就是：你不能可变借用 一个不可变值。如：
```rust
let x = 5;
let y = &mut x;
// error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
```
然而有的时候 一个值可以在它的方法中修改自己 同时对外又显示为不可变 会十分有用，外部代码无法修改这个值。使用 `RefCell<T>` 是获得这个内部可变能力的方法之一。但是其并没有完全逃避借用规则而的检查：虽然编译时内部可变被允许了，作为替代的，借用规则变为运行时检查，如果你违反了借用规则，会遇见 `panic!`。   
### 内部可变的一个使用案例：Mock Objects
一个 ***test double(测试替身)*** 是一个通用编程概念：测试时使用一个类型代替另一个类型。***Mock object(替身对象)*** 是测试替身的一个具体类型，它记录了测试中发生了什么，这样你可以断言正确的程序行为发生了。***Rust*** 没有和 其他语言拥有的对象 在同样意义上的对象，并且 ***Rust*** 没有像其他语言一样 内建在标准库中的替身对象功能。然而，你完全可以创建一个结构体，用作替身对象。     
跟随 ***Rust/mock_object/src/lib.rs*** 中的步骤，实现案例：
1. 两个重点：
   1. 模仿对象需要实现的特性，特性方法参数使用了一个不可变引用的 `&self`，和信息文本；
   2. 另一个重点是我们希望测试的方法，它没有任何返回值给我们来做断言
2. 根据上面两个重点，我们需要一个替身对象，能够把相关的信息存到自己的结构体中。但是 `send` 方法的只读引用 `&self` 限制了在其中对对象自身的修改，暨无法 `self.vec_string_field.push(xxx_string);`。
3. 这就是我们希望使用 内部可变模式 的时候。我们在替身对象中设置一个字段用来存储测试时传入的信息，使用 `RefCell<Vec<String>>` 作为它的类型。
4. 然后我们就可以使用 `self.refcell_vec_string_field.borrow_mut()` 来获得这个域存储值的可变引用，然后就可以用这个可变引用对内部值(示例中类型为 `Vec<String>`)进行改变。
### 使用 `RefCell<T>` 在运行时保持追踪引用
当创建 不可变引用 和 可变引用 的时候，我们使用 `&` 和 `&mut ` 语法。而使用 `RefCell<T>` 我们使用 `borrow` 和 `borrow_mut` 方法，是 `RefCell<T>` 的安全 API 的一部分。
1. `borrow` 返回智能指针类型 `Ref<T>`，而 `borrow_mut` 方法返回智能指针类型 `RefMut<T>`，两种类型都实现了 `Deref`，因此我们可以像普通引用一样操作他们。     
2. `RefCell<T>` 追踪了目前有多少 `Ref<T>` 和 `RefMut<T>` 智能指针存活。每次我们调用 `borrow`，`RefCell<T>` 增加目前存活的不可变引用计数，当一个 `RefCell<T>` 离开作用域，其不可变引用计数下降 1。      
3. 就像编译时借用规则一样，`RefCell<T>` 在任何时间点允许我们 **有很多不可变引用 或者 一个可变引用**。如果我们试图违反这些规则，`RefCell<T>` 的实现会 panic，而不是出现编译时错误
4. 运行时借用错误 意味着你可能在开发过程之后才会发现异常，而且很有可能直到部署产品时都没有发现。同时，使用这种代码会带来一个 小的额外性能开销，由于为了追踪引用。然而使用 `RefCell<T>` 使你可以写一个 可以修改自己来记录追踪它看见的信息而且上下文中此处仅可使用不可变值的 替身对象，就像示例代码一样。

## 通过组合 `Rc<T>` 和 `RefCell<T>` 来获得可变数据的多个拥有者
一个常见的 `RefCell<T>` 用法是配合 `Rc<T>`，`Rc<T>` 让你可以对某个数据有多个引用，但是只有不可变权限。如果有一个 `Rc<T>` 持有一个 `RefCell<T>` 数据，你就可以获得一个 可以拥有多个所有者并且可变的值！暨 `Rc<RefCell<T>>`。见：*Rust/box_learn/src/main.rs*      
标准库也有一些其他类型提供 内部变更模式，例如 `Cell<T>`，与 `RefCell<T>` 稍微不同的是它不是使用引用，而是将值复制进/出 `Cell<T>`；还有 `Mutex<T>`，提供了安全的跨线程 内部变更模式，我们在 [[14-无畏并发]] 中会使用，检索标准库文档查看更多。


# 循环引用能够造成内存泄漏
***Rust*** 的内存安全担保使 意外创建一个永远不会被清理的内存(aka. ***memory leak - 内存泄漏***) 很难，但并不是不可能发生。完全阻止内存泄漏并不是 ***Rust*** 的担保之一，意味着内存泄漏在 ***Rust*** 中是 内存安全。我们可以看见 ***Rust*** 通过使用 `Rc<T>` 和 `RefCell<T>` 允许内存泄漏：创建一个引用，其中的项目相互引用形成循环 是可能的。这导致了内存泄漏，因为 引用循环中每个项目的内存计数永远都不会到 0，因此值永远不会被 drop。

## 创建一个循环引用
1. 故意创建一个循环引用的步骤：
   1. 结构体/枚举拥有一个 `RefCell<Rc<T>>` 类型，或相似的 拥有内部可变模式特性的智能指针 包含  引用计数型智能指针 的类型，的域/变体。
   2. 依次创建满足条件的实例 `a`，然后是实例 `b`，创建实例 `b` 时，`b` 的结尾初始化为 `Rc::clone(&a)`。然后利用内部可变模式，将 `a` 的结尾修改为 `Rc::clone(&b)`，构成循环引用。当然，这只是最简单的环。
2. 如果我们刚创建了一个循环引用，然后程序结束了，这个后果不算很严重。然而，如果一个更加复杂的程序，在循环中分配了很多内存，并且持有了很长时间，程序会 比其正常的需求 使用更多的内存，并且可能会压垮系统，用尽内存资源。
3. 创建一个循环引用不是那么容易，但是也不是不可能。如果你使用 `RefCell<T>` 包含 `Rc<T>`，或者类似的类型嵌套组合：拥有内部可变模式的类型 和 引用计数类型，你必须保证不会创建循环。这点上，你无法依赖 ***Rust*** 来捕捉。
4. 创建一个循环引用可能会是一个 逻辑 bug，你应该使用 自动化测试，代码审阅，和其他软件开发实例来最小化其发生。
5. 另一个避免循环引用的的方案是：重新组织你的数据结构，这样一些引用表现出 所有权，一些没有。这样，你可以拥有一个由 一部分有所有权的引用关系 和 一部分没有所有权的引用关系 组合起来的循环，而只有前者影响一个值是否会被 drop 掉。如下节。

## 阻止引用循环：将一个 `Rc<T>` 转变为 `Weak<T>` 
迄今为止，我们已经证明了调用 `Rc::clone` 会增加一个 `Rc<T>` 实例的 `strong_count`，并且 `Rc<T>` 实例只有在 `strong_count` 为 0 的时候被清扫。你也可以在一个 `Rc<T>` 实例中，对那个值创建一个 ***weak reference(弱引用)***，通过调用 `Rc::downgrade` 并且传入一个 `Rc<T>` 的引用。当你调用 `Rc::downgrade`，你会获得一个类型为 `Weak<T>` 的智能指针，调用 `Rc::downgrade` 使 `weak_count` 增加 1，而不是增加 `strong_count`。`Rc<T>` 使用 `weak_count` 来追踪有多少 `Weak<T>` 存在，类似于 `strong_count`，不同的是 `weak_count` 不需要归 0，`Rc<T>` 就可以被清扫。
1. 强引用让你可以分享一个 `Rc<T>` 实例的所有权。弱引用不表示一个所有权关系，他们不会造成循环引用，因为任何有弱引用参与的循环，一旦参与值的强引用计数归 0 了，这个循环就破坏了，而它本身又不会影响强引用计数。
2. `Rc::downgrade(&val)` 将一个 `Rc<T>` 降格为 `Weak<T>`，暨 使用 `Rc::downgrade(&branch)` 函数从 `branch` 中的 `Rc<Node>` 来创建一个 `branch` 的 `Weak<Node>` 引用
3. `RefCell{value:(Weak)}` 通过 `.borrow()` 得到 `(Weak)` 再通过 `.upgrade()` 得到 `Some(origin_value)`，换句话说对于一个类型为 `RefCell<Weak<T>>` 类型的实例 `refcell_weak`：`refcell_weak.borrow().ungrade()` 返回 `Option<Rc<T>>`。
4. 由于 `Weak<T>` 引用的值有可能会被 drop，对 `Weak<T>` 指向的值进行任何操作前，你**必须**确认那个值还是存在的，通过调用 `Weak<T>` 中的 `upgrade` 方法，会返回一个 `Option<Rc<T>>`，如果 `Rc<T>` 还没被 drop，则这个返回值为 `Some(some_rc)`，如果 `Rc<T>` 已经 dropped 了，那么返回值就是 `None`。由于返回值是 `Option<Rc<T>>`，***Rust*** 会保证所有情况都被处理到，因此不会有非法指针。
5. 作为例子，我们创建一个树，同时直到它的子项目和父项目(双向链表)，而不是一个列表直到它的下一个项目。代码及相关记录见 *Rust/avoid_ref_cyc/src/main.rs*
### 创建一个树数据解构：一个拥有子节点的节点
创建一个可以访问子节点的节点：
```rust
struct Node {
   value: i32,
   children: RefCell<Vec<Rc<Node>>>,
}
```
我们希望 `Node` 拥有自己的子项目，并且我们希望和子节点变量分享这个 ownership，这样我们可以直接访问树中的每一个 `Node`，因此我们使用 `Vec<Rc<Node>>;`。并且由于 `Rc<T>` 只有不可变借用，我们还希望能够修改哪个节点是另一个节点的子节点，因此我们使用 `RefCell<T>` 在最外层。
### 增加一个从子节点到其父节点的引用
为了使子节点知道其父节点，我们需要增加 `parent` 字段，问题是 `parent` 的数据类型应该是什么，我们知道它不能包含一个 `Rc<T>`，因为那样可能会创建一个循环引用，当 `leaf.parent` 指向 `branch` 同时 `branch.children` 指向 `leaf`，那样他们的 `strong_count` 永远都不会为 0，造成内存泄漏。      
换个角度来思考其中的关系，一个父节点应该拥有其子节点：如果父节点 dropped 了，子节点也应该 dropped。然而，一个子节点不应该拥有父节点：如果子节点 dropped，父节点不应该受影响，依旧存在。这时候，就该使用 弱引用 了！如下：
```rust
struct Node {
   value: i32,
   children: RefCell<Vec<Rc<Node>>>,
   parent: RefCell<Weak<Node>>,    
   // 这样一个子节点可以访问父节点，但是并不 拥有 父节点
   // 通过使用 Weak<T> 我们不仅让子节点能够访问父节点，而且避免了最终造成栈溢出的循环引用。
}
```
### `strong_count` 和 `weak_count` 的可视化改变
创建不同的域，输出 `strong_count` 和 `weak_count` 自行观察。
1. 所有管理 计数器 和 value dropping 的逻辑都内建于 `Rc<T>` 和 `Weak<T>` 并且他们都实现了 `Drop` 特性。
2. 如代码中所展示的，通过明确关系定义 `Node`：从子节点到父节点应该是一个 `Weak<T>` 引用，你可以在不创建引用循环和造成内存泄漏的前提下 拥有双向链表(树)。
3. 如果这章摧毁了你的兴趣，你想创建自己的智能指针，查阅 [The Rustonomicon](https://doc.rust-lang.org/nomicon/index.html)。**但是注意！！！"Should you wish a long and happy career of writing Rust programs, you should turn back now and forget you ever saw this book([The Rustonomicon](https://doc.rust-lang.org/nomicon/index.html)).** **It is not necessary**"


# 代码
- ***Rust/box_learn/src/main.rs***
- *Rust/deref_learn/src/main.rs*
- *Rust/drop_learn/src/main.rs*
- ***Rust/mock_object/src/lib.rs***   
- *Rust/refcell_learn/src/main.rs*
- *Rust/reference_cycle/src/main.rs*
- ***Rust/avoid_ref_cyc/src/main.rs***