1. 定义了，但未使用的函数、变量会有 warning，可以使用 `_varname` 来避免
2. ***Rust*** 有一系列保留的 ***keywords***，查阅 [Appendix A](https://doc.rust-lang.org/book/appendix-01-keywords.html)。
3. ***Rust*** 有 `{}` 作用域，每一个 `{}` 都是一个域；
4. 更多操作符，查阅 [Appendix B](https://doc.rust-lang.org/book/appendix-02-operators.html)。
5. ***Rust*** 代码使用 **snake case(蛇形命名法)** 命名函数和变量，暨所有字母都小写，使用 `_` 分割不同单词。
6. 栈 Last in, first out；堆 随机；因此 栈 的速度更快
7. 所有存在栈上的数据必须是已知且定长的，如果长度未知或者可能会改变，则必须存在堆里
8. 堆中存储数据，需要分配内存(allocating on the heap => allocating)，然后返回指针，由于 指针 是定长且不变长的，因此可以存到 栈 中
9. 当堆中的数据很大时，深拷贝十分的影响性能
10. 当你调用函数的时候，传入函数的值(包括可能的是指针)和函数本地的变量被压入栈中，运行完成后被弹出。 
11. 两个指向同一地址的变量，超出作用域时，会释放同一地址内存两次，被称为 ***double free*** 错误，是一种内存安全bug，可能导致内存损坏，潜在导致安全漏洞 
12. ***Rust*** 永远不会自动为数据创造深拷贝，因此，任何自动拷贝都会被认位是 运行性能昂贵的。如果需要，考虑clone 
13. ***Rust*** 有一个特殊标记，叫做 Copy trait，如果一个类型实现了 Copy trait，则这个类型的一个对象变量在赋值给另一个对象的时候，旧的对象不会失效。但是，如果一个类型，或者此类型的任何一部分，已经实现的 Drop trait，***Rust*** 禁止标记这个类型为 Copy，如果类型需要在值超出作用域时发生一些特别的事，并且我们增加了 Copy 标识到此类型，会导致编译时错误。[Trait 参考表](https://doc.rust-lang.org/book/appendix-03-derivable-traits.html)
14. 如果既想传入堆变量，又想在函数调用后继续使用这个堆变量，就需要在 `return` 值中返回堆变量(可以用tuple返回多个变量)，如果不想如此冗余，***Rust*** 提供了一个特点，使用变量但不传输 ownership，叫做 reference (参照)
15.  ***Rust*** 永远不会自动创建 深拷贝。
16. ***Rust*** 引用的规则在编译时就消除了一系列的 error 
17. struct 存储 reference 也是可能的，但是需要设置 lifetimes，如果直接把 String 换成 `&str`，会编译错误：*error[E0106]: missing lifetime specifier*
18. 定义多个 结构体、枚举、函数、方法 时，中间不需要任何符号分割 
19. 标准库中的内容并不是默认引入的，只有部分被默认引入，不需要 `use` 导入 就可以直接使用，称之为 ***Prelude(序曲)***
20. ***Rust*** 文件后缀 *.rs* ，如果多个单词作为文件名，使用 _ 进行连接
21. 无返回值的 函数、Expression 的返回值默认为 `()` ，意义上等同于其他语言中的 void  
22. method 无法和 struct 一起定义，必须先定义好 struct 然后 `impl` 他来增加 method 定义
23. `struct`, `fn`, `enum` 的定义是可以在 *main.rs* 源代码 的任何位置(前后)定义的，都是可以访问到的，除非定义在域中，域外是无法访问到的，但是合适的代码管理会将 定义 等放到 库 中，就按私密标识进行访问限制。
24. ***Rust*** 中的 *函数、方法、变量* 使用的是 **`_` 分割命名**，而 **类、枚举、枚举变体** 使用的是 **驼峰命名**。如：
    ```rust
    fn function_name() {}
    struct StructName {}
    enum EnumName { ValNameA, ValNameB }
    ```
25. 注意，由于 ***Rust*** 没有 `null`，所以 只声明不初始化 一个变量虽然 可以，但**是一旦在使用前没有初始化改变量，则直接无法编译通过**
26. ***Rust*** 的快速、安全、单二进制输出和跨平台，使她成为了一个理想的命令行工具编写语言  
27. ***Rust*** 的类名惯例上使用 ***CamelCase(驼峰法)*** 命名。
28. [编写一个猜数游戏](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html) 代码：***Rust/guessing_game***
29. `println!("{}", v);` 中的 `{}` ，格式化调用的是 `Display` ，没有实现的话是无法编译通过 `println！`来显示客制化类型数据的，如下修改：
   1. 把 `{}` 改为 `{:?}` , 这里告诉 `println!` 我们想用一种输出格式叫做 Debug ，一种利于开发者 debug 的输出格式 
   2. 在 `struct` 定义前一行 增加 `#[derive(Debug)]` 
   3. 把 `{:?}` 改为 `{:#?}` ，更易读   
30. 另一种输出 Debug 格式的方法是使用 `dbg!` 宏，**会获取一个表达式的 ownership** ，输出 `dbg!` 发生的文件路径和行，还有表达式的值(同 Debug 格式)，**并返回该值的 ownership**。当然，可以使用 `dbg!(&var)` 来避免被夺走所有权。
31. 注意：`dbg!` 宏输出到 标准错误终端流(stderr)，`println!` 宏输出到标准输出终端流(stdout)
32. [一个 I/O 项目：构建一个命令行程序](https://doc.rust-lang.org/book/ch12-00-an-io-project.html) 代码：***Rust/minigrep***。以下笔记直到 都是关于这个项目的。
33. grep (**g**olbally search a **r**egular **e**xpression and **p**rint)
34. 为了实现读取 `cargo run` 的命令行参数的功能，我们需要一个 ***Rust*** 标准库提供的函数：`std::env::args()`。
35. `std::env::args()` 遇见非法 Unicode 字符的时候会 panic，如果需要接收非法 Unicode 字符，需要使用 `std::env::args_os()` 方法，返回值是元素为 `OsString` 的迭代器，是一个更加复杂的变量，并且每个平台会有区别。
36. `std::env::args()` 返回的第一个值是 使用这个函数的二进制文件的名字。
37. `main` 函数中不要写太多代码，将功能分成多个独立的函数，每个函数只做一件事，再调用这些函数，更利于维护。并且变量也需要分类整理，来使他们的目的更清晰，不会随着项目的扩大而变得难以理解、区分。
38. 异常处理反馈的信息要明晰，让用户知道为什么失败，如何成功。并且，将错误处理代码逻辑集中，有利于后续的维护，并且也会提醒我们使用更明晰的错误信息。
39. Rust 社区总结的分离函数功能到独立文件的步骤：
    1. 将程序分为 *main.rs* 和 *lib.rs*，并且将程序逻辑移到 *lib.rs*;
    2. 只要你的命令行解析逻辑很小，它可以留在 *main.rs* 中；
    3. 当命令行解析逻辑开始变得复杂，将其从 *main.rs* 中提取出来放到 *lib.rs* 中；   
40. 完成以上步骤后，留在 `main` 函数中的值则应该仅限于以下几种：    
    1. 调用命令行解析逻辑和参数值；
    2. 设置其他的设置项；
    3. 调用 *lib.rs* 中的一个 `run` 函数；
    4. 处理 `run` 函数可能返回的错误；
41. 42 & 43 就是分离步骤，这个步骤是关于分离重点的：*main.rs* 负责运行程序，*lib.rs* 负责持有所有的业务逻辑。虽然不能够测试 `main` 函数，但是我们可以测试 *lib.rs* 也就是所有的业务逻辑，而 *main.rs* 中剩余的逻辑很少，不需要测试。
42. 在很多 ***Rust*** 程序员之间有一种趋势，是避免使用 `clone` 来修复 ownership 问题，因为它的运行时损耗。后面会学到如何使用更有效率得方式处理这种情况。但是现在就直接使用，因为我们已经知道 `clone` 得次数不多并且 `String` 也不大，这是有一点点“不效率”是好过过优化你的第一个代码的。
43. 当一个函数返回值是一个自定义类型的时候，考虑如果语义合适，将这个函数转化为 那个自定义类型的 `new` 方法，更地道(idiomatic)
44. 我们把一些异常包装为 `Result<T, E>` 返回，当 `main` 函数获得这个值的时候，可以统一处理，并且有些可预测的异常可以将程序以 非零错误代码 进行退出，非零退出状态是一个习俗，用来知会调用我们软件的进程 程序以异常状态退出，这是从 用户友好 考虑进行的改进，这样的退出只会有这一条额外信息，不会再有 paniked 那些多余杂乱的信息：
> error: process didn't exit sucessfully: `file_path\project.exe` (exit code: 1); 
45. 非零退出：
   ```rust
   use std::process;
   fn main() {
      println!("Some error message");
      process::exit(1);   // 参数即为输出的 exit code: num 中的 num
   }
   ```
46. 我们抽离的 `run` 函数，返回值 通常为 `Result<(), Box<dyn Error>>`，`Ok(())` 是十分地道的用法，来体现我们只需要 `run` 函数的 “副作用”，并不需要它的返回值。而 `Box<dyn Error>>` 是代指实现的 `Error` 特性的所有 类。
47. 需要使用返回值的异常处理：
    ```rust
    let v = some_result.unwrap_or_else(|err| {});
    ```
    不需要使用返回值的异常处理：
    ```rust
    if let Err(e) = some_result {}
    ```
48. *src/main.rs* 中调用同项目的 *src/lib.rs* 项目，`use project_name::Item;` 以 `project_name::` 作为路径根，注意库中的项目要 `pub` 。但是直属的一级函数不需要，可以直接通过 `project_name::root_path_function` 来调用。
49. 注意，VSCode 似乎无法识别这种同级的包的导入，代码提示会报错，但是实际是可以编译成功的。使用 ***rust-analyzer插件***(持续更新中) 替代 ***Rust插件***(2020年停更) 可以解决这个问题。
50. ***Test-driven development(TDD)*** 测试驱动开发，有以下几步
    1. 写一个预期结果为失败的测试，运行，保证代码 以期望的方式 失败；
    2. 写或者修改，刚好使新代码通过测试；
    3. 重构刚增加/修改的代码，并且保证测试始终通过；
    4. 重复以上步骤；
51. ***Rust*** 中的 `&str` 字面量，会将输入的回车、控制、制表也记录，因此，如果希望代码中的两行，实际输出为一行，需要再中间回车的前面使用反斜杠 `\`，有点像 ***Python***。由于空格，制表符都会被记录，因此多行字符串一定要注意，很可能会多出几个空格、制表符在每行的开头
52. 环境变量的包是 `std::env`，查找环境变量：`env::var("ENV_KEY").is_err()`，`.is_err()` 是当值为 `Err` 的时候返回 `true`，其他情况返回 `false`
53. ***powershell*** 中设定的环境变量是临时的，重启 ***powershell*** 就会被删除，但是如果不重启，则一直存在，除非使用 Remove-Item 命令：命令不区分大小写，但是 KEY, VALUE 都是区分大小写的，可能因为会被读入程序；
> $env:KEY=value; // Windows 10 powershell $Env 也可以，不区分大小写
> RUST_BACKTRACE=1 cargo run  // ***Linux*** / ***macOS*** / ***UNIX*** ***bash***
> Remove-Item Env:KEY          // Windows 10 powershell
54. 所以，命令行工具有两种传入参数的方式，一种是 `env::args().collect()` 另一种是 `env::var("ENV_KEY")`，甚至可以两种都用来控制同一种程序功能，但是因为有冲突，所以要确定优先级
55. 多数终端都有两类输出：standard output (stdout) 来输出通用信息；standard error (stderr) 来输出异常信息。这个区分使用户可以选择将成功信息导出到一个文件中，但是仍将异常信息打印到屏幕上。将标准输出流导入到文件中：   
> cargo run > some_file_with_.filetype  // (创建、)清空文件，并写入
56. 将异常信息打印到标准异常输出更有用，这样 只有 一个成功运行输出的输出最终会被导入到文件中，而异常的则不会进入到文件，而是直接在控制台显示。`println!()` 只能打印到 标准输出，所以我们需要其他方法来打印到 标准异常。`eprintln!()` 宏可以将信息打印到标准异常流。
57. 函数是可以定义在函数中的，但是(显然)内部函数无法被外部访问。
58. ***Rust*** 的开源协议：双许可 - `MIT OR Apache-2.0` 
59. 为什么要使用 `Box<T>`, `Rc<T>`, `RefCell<T>`:
    1. `Rc<T>` 允许相同数据拥有多个所有者；`Box<T>` 和 `RefCell<T>` 有单个所有者；
    2. `Box<T>` 允许**编译时检查的 不可变 或者 可变借用**；`Rc<T>` 仅允许**编译时检查的 不可变借用**；`RefCell<T>` 允许**运行时检查的 不可变 或者 可变借用**；
    3. 因为 `RefCell<T>` 允许运行时检查的 可变借用，你可修改其中的值，即使 `RefCell<T>` 对象本身是不可变的，而这就叫做 内部变更模式
60. 打印变量类型，使用 `std::any::type_name<T>()` 配合泛型完成：
    ```rust
    pub fn print_type_of<T>(a: &T) {
       println!("intput value's type is {}", std::any::type_name::<T>());
    }
    ```
50. 由于 ***Rust*** 默认私密，加上封装特性，因此使用库的时候，优先想到的是方法，即使看起来用的像是字段，如 `len()`，但是标准的实现方式不会暴露字段，而是给一个 getter 函数，因此使用别人的库/创建自己的库的时候，也是优先这种习俗
51. 显然，***Rust*** 也是有逻辑短路的
52. 单元素元组 `(3,)` 
53. ***concurrency primitives(并发原语)*** - 是并发安全的数据类型。
54. CRLF - _carriage return_ and _line feed_，aka `\r\n` 。
55. ***Thread pool(线程池)*** 是一组派生线程，等待和准备执行任务。当程序收到一个新任务，它安排线程池中的一个线程来执行这个任务，剩余的线程继续等待，当下一个任务进来且第一个线程还在执行任务的时候，就从剩余的线程中分派任务。当第一个线程结束了任务，它返回线程池，等待执行任务。允许你并发处理链接，提高服务器吞吐量。
56. 我们限制线程池为一个较小的数目来保护我们减轻 DoS 攻击。
57. 线程池只是很多提高服务器吞吐量的技术之一。还可以使用 fork/join 模型、单线程异步 I/O 模型。
58. 当你写代码时，可以，先写客户端接口可以指引你的设计，按照你希望调用 API 的方式来写 API，而不是实现功能然后设计公有 API。类似于 TDD，我们也可以使用 ***CDD - compiler-driven development***。我们写调用我们想的函数的代码，然后分析编译器报错来决定需要修改什么。
59. `FnOnce()` 代表的是一个闭包，如果代表的闭包没有返回值，可以省略，但是即使如果没有参数，不能省略 `()`
60. `thread::spawn` 的函数标签：
   ```rust
   pub fn spawn<F, T>(&self, f: F) -> JoinHandle<T> 
   where F: FnOnce() -> T,
         F: Send + 'static,
         T: Send + 'static,
   {}
   ```
61. 如果我们提前知道向量的总大小，使用 `Vec::with_capacity` 提前将空间分配好，比使用 `Vec::new` 效率高一点，因为不需要在元素增加时重新变更大小。
62. `take` 方法定义在 `Iterator` 特性中，限制迭代器最多仅迭代前两个项目。
63. `u` 系列数字，做减法的时候要注意，因为其下限是 0，非常容易 overflow，因此比较的时候改为两个数字比较大小，而不是和 0 比较；并且再范围索引时 `&s[a..b]`，如果 `b < a` 也会 overflow。 
64. 注意 `println!` 也是对耗时有不少影响的，尤其是当其出现在循环体中时，当发布前记得全部注释/删除。