# 变量 和 可变性
1. 变量默认是不可变的。使用 `let var = some_val;` 来声明
2. 可以增加 `mut` 来使变量可变。如：`let mut var = some_val;`。
3. 有多个因素需要权衡，包括阻止 bug。例如，当你使用大型数据结构，在原地修改一个实例 比 复制、修改、返回新实例更快；而比较小的数据结构，创建一个新的实例，然后以更函数式编程风格的方法来写更容易理解，因此稍差的性能换取更明晰的表达可能是更值得的。

## 常量

^Constants

1. 常量使用 `const` 声明，而不是 `let`。
2. 常量不能使用 `mut` 关键字标记，默认实不可变的。
3. 常量必须有类型标记，既：`const PI: u32 = 3.1415;`
4. 常量可以在任何域中声明，***Rust*** 有 `{}` 作用域，每一个 `{}` 中都是一个域，包括全局域，这使它们可以被代码的每一部分都知道，十分有用。
5. 常量只能被赋予常量表达式，而不是一个只在编译时计算出的结果。如：`const THREE_HOURS_IN_SECONDS: u32 = 3 * 60 * 60;`
6. 常量命名惯例以全大写，词间使用 `_` 链接来命名。命名一些常量，如 3.1415926、10800 等 为 `PI`, `THREE_HOURS_IN_SECONDS`，远比使用硬编码的数字利于理解。
7. 常量在程序的整个生命周期都是有效的(在其声明的作用域内)

## Shadowing
重复声明初始化 **同名变量** 被称为 ***shadow***，shadow 直接考虑为重新声明了一个新的变量即可，没有限制，无论是 修改为是否是 `mut` 还是干脆换个数据类型。shadow 更准确地说是第二个变量才是程序看到的变量，直到它离开作用域失效。例如：
```rust
fn main() {
   let x = 5;
   let x += 1;
   {
      let x = x * 2;
      pritnln!("The value of x in the inner scope is: {}", x); // 12
   }
   println!("The value of x is: {}", x); // 6
}
```
shadowing 和 mut 的区别：
- 如果不使用 shadow 是无法改变一个非 mut 变量的值的；   
- shadow 可以考虑为重新声明了一个变量，因此可以改变类型；


# 数据类型
***Rust*** 是静态类型语言：编译时必须知道所有变量的数据类型。通常情况下，编译器能够通过 值 和 我们使用它的方式 推断出类型，所以可以不标注类型。但是，当多个类型都有可能的时候，我们必须标注，如 `parse` 函数： 
```rust
let guess:u32 = "43".parse().expect("Not a number");
```

## 标量类型
一个 ***scalar(标量)*** 类型代表一个单一的值。***Rust*** 有 4 个主要的标量类型： **integer**, **floating-point number**, **Boolean**, **characters**
### Integer 类型
1. `i8`/`u8`, `i16`/`u16`, `i32`/`u32`, `i64`/`u64`, `i128`/`u128`, `isize`/`usize`(由操作系统决定，和操作系统位数相同)。 `i` 有符号型 或 `u` 无符号型，组合 不同的 bit 位数 8/16/32/64/128/size，构成了整型家族。
2. `size` 取决于软件运行所在的电脑架构：64 位架构就是 64-bits，32 位架构就是 32-bits。
3. 使用以下格式都可以复制整型变量：D: `92_333`; H: `0xff`; O: `0o77`; B: `0b1111_0000`; Byte: `b'A'`
4. 整型的默认类型是 `i32`，索引组合的时候，使用 `isize`/`usize` 最好
5. 使用终端命令 `cargo build --release` 时，不会检查整数溢出(而没有 --release 的时候，暨 debug 模式下 程序会 panic，panic 用来描述 程序由于 error 退出)。当使用 --release 的时候，如果溢出发生，使用 2 进制补码，暨256 -> 0, 257 -> 1 来处理可能的溢出：
   1. 使用 `wrapping_` 系列方法，如 `wrapping_add`，任何模式下(无论是否 --release)都使用 2进制补码；
   2. 使用 `checked_` 系列方法，溢出时返回 `None`；
   3. 使用 `overflowing_` 系列方法，返回结果值和一个布尔值 `(value, isOverflow)`，反应是否溢出；
   4. 使用 `saturating_` 系列方法，在遇见类型的上下界时饱和；
### 浮点类型
***Rust*** 中浮点类型有两种：`f32` 单精度, `f64` 双精度(default，因为现代计算机处理它们的速度差不多，但是双精度浮点的精度更高)。并且所有浮点类型都是有符号的。
### 数字操作
 ***Rust*** 支持基本的数学运算：加减乘除(`+`, `-`, `*`, `/`) 和 取余(`%`)。
 1. 整数除法 下舍入 至最近整数，暨：**向 0 舍入至最近整数 - 暨截断小数**。7 / 3 = 2 而 7 / -3 = -2，-7 / 3 = -2；
 2. 取余，**符号 和 左侧值 相同**，值按绝对值计算结果即可。
 3. 更多操作符，查阅 [Appendix B](https://doc.rust-lang.org/book/appendix-02-operators.html)。
### 布尔类型
布尔值占用 **一个字节**。类型为 `bool`
### 字符类型
***Rust*** 的 `char` 类型是语言最原始的字母类型。一些例子：
```rust
fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';
}
```
1. 注意，`char` 字面量使用 **单引号**，和字符串字面量的双引号进行区分。
2. ***Rust*** 的 `char` 类型为 4Bytes 编码的Unicode Scalar Value，从 U+0000 到 U+D7FF，和 从 U+E000 到 U+10FFFF 除去高位代理和低位代理之外，所有的 Unicode 码位，暨 UTF-8。但是人类理解的字符和 ***Rust*** 中的 `char` 并不完全一样，我们在 [[7-通用集合#^Storing-UTF8-Encoded-Text-with-Strings]] 中会详细讨论 

## 复合类型
复合类型能够将多个值存在一个类型中，***Rust*** 有两种基本复合类型：tuples(元组)，arrays(数组)。
### 元组类型

^The-Tuple-Type

**Tuple(元组)** 是一个 将多个不同类型的值集合起来放进一个复合类型中的 常规方法。元组长度固定：一旦声明，不能增大或缩小。
1. 声明，类型可以让他自动推断：`let tup = (500, 6.4, 1);`
2. 我们可以使用解构赋值，获得元组内的值：`let (x, y, z) = tup;`。还可以通过 `.` 来访问特定位置的值：`let a = tup.1;`
3. 空元组 `()`，类型为 **单元类型**，值为 **单元值**，全都写作 `()`。表达式如果不返回任何值，则隐式地返回 `()`，此处作用类似于其他语言的 void。
### 数组类型
另一种拥有多个值的集合的方式是 **Array(数组)**。和元组不同的是，数组中的每个元素**必须是相同类型**，和其他语言不同的是，数组必须是**固定长度**的。
1. 声明：`let a = [1, 2, 3, 4, 5];`
2. 当你希望数据分配在 **栈(stack)** 而不是 **堆(heap)** 上时(我们将会在 [[3-理解Ownership(所有权)]] 更深入讨论堆和栈)，数组十分有用；或者当你希望总是拥有固定数量的元素时。
3. 数组并不像向量那样灵活，向量是一个类似的集合类型，由标准库提供，允许可变大小，暨内部元素数量可变。如果你不确定自己想用数组还是向量，你应该使用一个向量。[[7-通用集合#^Storing-Lists-of-Values-with-Vectors]] 中我们会更详细地讨论向量。
4. 数组类型使用 `[Type; size]`，如：`let a: [i32; 5] = [1, 2, 3, 4, 5];`
5. 可以使用语法 `let a = [3; 5];`，来获得一个含有 5 个 3 的数组，和 `let a = [3, 3, 3, 3, 3];` 是等价的，但是更简洁。
6. 访问数组元素使用 `arr[index];` 语法，如：`a[0]`。
7. 访问超过元组、数组长度的元素(越界)，会导致程序 panic，编译失败或者运行时错误，程序退出


# 函数
使用 `fn function_name() {}` 定义函数，位置(指前后)影响不大，只要定义了就好，但是外层不能访问内层域中定义的函数。
## 参数
1. `fn(parameters: Type) {}; fn(argument);` parameters - 形参; argument - 实参；
2. 在函数定义中，你 **必须** 声明每个参数的类型。
## Statements(语句) 和 Expressions(表达式)
函数体是由 一系列语句 和 (可选的)表达式结尾 组成的。
1. ***Rust*** 是一个基于表达式(expression-based)的语言，因此明白语句和表达式间的区别很重要。语句(Statements)是 无返回值的动作；而表达式将评估为一个 结果值。
2. 语句没有返回值，因此你无法将语句赋值给另一个变量，如果你这样做了，会获得一个编译错误。这和其他的语言可能不太一样，***C*** 和 ***Ruby*** 的 Statement 就有返回值，可以赋值给别人，因此他们(***C***, ***Ruby***, etc)可以 `x = y = 6;` 这样连续赋值，***Rust*** 中是不可以的。
3. 表达式将会评估为一个值，它组成了 绝大多数你使用 ***Rust*** 编写的 剩余的代码，例如 `5 + 6`。表达式也可以是语句的一部分：如赋值 `=` 右边的部分。
4. 函数定义是一个语句。而函数调用是一个表达式。
5. 表达式(Expression)评估来产生一个值。如：注意符号，如果 `x + 1` 后面有 `;` 会导致其变成一个没有返回值的 Statements。表达式没有结尾的 分号
   ```rust
   let y = {
      let x = 3;
      x + 1
   };
   ```
   如果能将一串代码作为参数传递，就是 expression
6. Statement: 没有返回值，因此 如果将一个 `let` 语句赋值给另一个变量，会报错，常见的语句：
   1. 声明、初始化一个值；
   2. 函数定义；
7. Expression: 会被评估为一个值，组成了 ***Rust*** 中大多数的代码，如
   1. `5 + 6`
   2. 可以作为 Statement 的一部分，如 `let a = 5;` 中的 `5` 
   3. 调用 **函数**
   4. 调用 **宏**   
   5. 如 5. 中例子，一个有返回值的域   

## 有返回值的函数
1. 语法：`fn func(para: InType) -> OutType {}`，返回值需要明确类型，不需要注名，默认以函数体 `{}` 中最后一行的 expression 为返回值，可以使用 `return` 提前返回，但是大部分函数隐式地返回最后一行表达式的值。
2. 注意语法中的符号和 ***swift*** 一样: 是 `->` , 而不同于 ***JS*** 是 `=>`
3. `fn func(para) -> (Type1, Type2) { (var1, var2) }` 返回值可以是 Tuple，来返回多个值，类似于 ***swift***。


# 注释
***Rust*** 中使用 `//` 开头注释一行内容。   
***Rust*** 还有一类文档注释，我们在 [[12-更多关于Cargo和Crates.io的内容#^Publish-a-Crate-to-Crates-io]] 中详细讨论。


# 控制流
## `if` 表达式
1. 语法：
   ```rust
   if Condition {} 
   else if Condition {}
   ...
   else {}
   ```
2. `if 条件 {}` ***Rust*** 的条件**不进行自动类型转换**，因此**条件类型必须为 `bool`**，比如常见的 `1` 之类的在 ***Rust*** 中都是不可行的，会产生编译错误，类型不匹配。
3. `if` 条件系列语句，**只会执行第一个满足条件的语句**，之后**跳过其余的语句**(无论是否符合条件，因为根本不会解析是否为 `true`，暨如果条件是一个表达式，不会运行、评估)，如：
   ```rust
   let mut a = 10;
   if a == 10 {}
   else if {
      a += 1;
      true 
   } {}
   println!("a == {}", a); // a == 10
   ```
4. 使用太多的 `else if` 使你的程序杂乱，如果超过一个，你可能需要考虑重构。[[5-枚举和模式匹配]] 中我们会讨论一个强大的分支结构叫做 `match` 来应对这种情况。
5. ***Rust*** 中没有三元运算符，可以使用 `let vari = if condition { val1 } else { val2 };` 来代替，注意返回值必须是 Expression 因此不能有 `;` ，并且所有 分支 都必须返回相同类型的值，否则会编译错误。
   
### 在 `let` 语句中使用 `if` 
`if` 是一个 Expression，因此可以有返回值，可以用在 `=` 右侧，但是所有分支的返回值类型都要相同，因为变量需要在编译时确定类型，否则会产生编译错误，因此要避免假定类型的变量，当无法确定的时候，推荐直接标识类型 `let v: Type`

## 使用循环 重复
***Rust*** 有三种类型的循环：`loop`, `while`, 和 `for`。常见的中断关键字 `coutinue` 和 `break` 也是有的
### `loop` 永久循环
永久循环，直到循环体中执行了 `break;`，语法：
```rust
loop {
   ...
   if xxx {
      break return_value;
   }
}
```
一个 `loop` 的用法是不断尝试一个你知道可能失败的操作，例如检查一个线程是否完成了它的工作，你可能也需要将操作的结果传出循环给你其他的代码使用，可以通过以下方式返回值：你可以在 `break` 后增加你想返回的变量(值)，此值会作为 loop Expression(loop块) 的返回值，可以用于 `=` 右侧；注意，格式为： `break var_value;`，有 `;` 结尾。多个返回分支，类型必须相同，否则编译失败。   
### `while` 条件循环
依据条件是否为 `true` 决定是否继续循环，可以使用 `loop` 实现，但是这个模式太常见了，因此 ***Rust*** 内建了一个拥有这个功能的结构 `while`，语法：
```rust
while Condition {
// 条件没有 `()`, 增加 `()` 会导致 warning，但不会报错
   ...
}
```
只要条件还是 `true`，就不会停止循环，反之，停止退出循环。
### `for`  遍历一个集合
你可以使用 `loop` 或者 `while` 来遍历一个集合，但是很容易犯下角标越界的错误 或者是 条件错误(其实避免使用硬编码可以避免这种错误，比如用 `.len()` 替换 `5`)，更精确 且 不易出错 的替代是使用 `for` 遍历，语法：
```rust
let a = [10, 20, 30, 40, 50];
for el in a {}
```
由于其精确性和安全性，`for` 循环是 ***Rust*** 中最常使用的循环，即使是在 你希望运行代码一定次数 的情况下，例如倒数。大多数的 ***Rust*** 人会选择使用 `for` 循环配合 `Range`，如：
```rust
for number in (0..10).rev() {
   println!("{}", number);
}
println!("LIFTOFF!");
```
### 小结
 1. 三种循环都可以以 `'some_name:` 前缀来命名循环块；循环 的名字 `'name` 只在 **这个循环** 的 `{}` 中有效
 2. `break`, `continue` 默认是中断、跳过当前位置的最内层循环(不算再此层下再嵌套的循环)，可以使用格式:   `'loop_name: loop {}` 对 `loop` 进行命名，`break` 和 `continue` 时，跟上 `'loop_name` 即可指定中断/跳过的循环层。
 3. 三种循环都是 Expression(可用于 `=` 右侧)，`while` 和 `for` 可以在 **代码块最后** 使用 expression 返回值，但是此处只能返回 `()`，其实 ***Rust*** 中无返回值的函数就是隐式返回的 `()` 的，所以本质上还是无返回值。`()` 类似于其他语言中的 `void`，是用来代指一个无用的返回值，虽然这个返回值是可赋值出去的，但是实际应用时是无用的，因为只能返回 `()` - 单元类型只有这一个值。
 4. 而对于 `loop`，注意： `loop` 无法自动出循环，如果没有 `break val;` 语法来返回值，那么其返回类型是永不类型 `!`，[[17-高级功能]] 会讲，而且一个无限循环的“代码块最后”道理上无意义)，但是它可以通过 `break val;` 来真正地返回值。
 5. 因此，实际上讲，三个循环表达式，只有 `loop` 可以通过 `break val;` 来返回一个有用的 `val` 值；
 6. `loop` 拥有名字标识 和作为表达式 不冲突，可以 `let a = 'loop_name: loop {}`
 7. 和其他语言不一样的是 ***Rust*** 中  `for` 只有 `for el in arr`，用来遍历集合，没有常见的 `for (;;)` 语法，部分情况可以通过遍历数字集合(Range) `start..end` 进行实现(包左不包右)


# 代码
- *Rust/loop_learn/src/main.rs*
- *Rust/variables/src/main.rs*
- *Rust/branches/src/main.rs*
- *Rust/functions/src/main.rs*

