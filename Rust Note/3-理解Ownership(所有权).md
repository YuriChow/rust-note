# 什么是 Ownership(所有权)
***Ownership(所有权)*** 是 ***Rust*** 最独具一格的特点，在没有垃圾回收机制的条件下，保证了内存安全。   
***Rust*** 通过 **一组拥有一系列被编译器检查的规则的所有权** 来管理内存，编译时会按规则检查，如果有不满足，则编译失败，都发生在编译时，因此编译成功的程序运行速度不会受影响。   
追踪 **堆** 上的数据，最小化堆上的复杂数据，清理无用数据，因此你不会用尽堆内存，这是 **ownership** 来解决的问题；  
所有权的主要目的是管理堆数据，可以帮助解释为什么它这样工作。
## 所有权规则
1. ***Rust*** 中的每个值有一个变量，称为它的 ***owner (所有者)***；
2. 每次只能有一个 **owner**；
3. 当 **owner** 超出作用域的时候，值会被 ***drop(废弃)***；

## 变量作用域
***Scope(作用域)***：程序中 变量有效的区域，包括：`{ let s = "hello"; }` 暨 定义后 到 `}` (最多，因为期间也可能会被夺走所有权)。   
换句话说，有两个时间点很关键：
- 当变量(如 `s`)进入作用域，它开始生效；
- 它维持生效，直到它离开作用域；
1. 返回值也可以转化成 ownership
2. 变量的 ownership 每一次有个固定的模式：通过赋值给另一个变量来 **moves it**；当堆上的变量(暨实现了 `Drop` trait 的)超出作用域时，就会通过调用 **drop** 来清理内存，除非 ownership 被 move 到了其他的变量；
3. 完全存在栈上的变量(实现了 `Copy` trait 的类型)，只会被 **copy**，不会被 move，从而导致原变量失去 ownership，只有堆上变量会。因为不需要担心 多重释放 bug，也因此对于 栈变量 深拷贝和浅拷贝没什么区别

## `String` 类型
其他复杂的数据类型，无论是库中的还是自己创建的，都可以参考 `String`，我们会在 [[7-通用集合]] 进行更深入的讨论。
1. 字符串字面量类型 `&str`，字符串类型 `String`，注意区分，因为字面量不会自动转换(或者说自动装箱)为 `String` 类型。
2. 从字面量创建 `String` 对象: `let s = String::from("Hello");` `String` 对象是可变的。这个语法我们在 [[4-使用结构体组织相关数据#^Method-Syntax]] 中讨论，命名空间我们在 [[6-使用包&箱&模块管理增长的项目#^Paths-for-Referring-to-an-Item-in-the-Module-Tree]] 中讨论   

## 内存和分配
1. `String` 对象存储于堆中；字面量是直接硬编码进最后的执行文件的，更快更高效，但是这些优点都是来源于其不可变的特性基础上
2. 为了保证 `String` 对象的可改、可增长，需要在堆中分配内存，意味着：
   1. 运行时，必须向内存分配器请求内存 --- 在我们新建对象的时候已经完成了
   2. 对象使用完成，需要一种方法还回此内存空间 --- 有 GC 的编程语言，靠 GC；没有 GC 的编程语言，靠自己。   
3. 而 ***Rust*** 用了不同的方法：当 拥有此变量的 变量 一超出作用域时，就自动归还内存
4. 正确地手动释放内存是一个编程的历史难题：如果忘记了，我们浪费了内存；如果释放早了，我们获得了一个非法的值；如果释放了两次，也是一个 bug - ***Double Free Error***。
5. ***Rust*** 内存归还：
   ```rust
   {
      let i = 32;
      let s = String::from("Hello");
   }              // 此作用域结束，i, s 都不再有效
   ```
   当一个堆变量出作用域，***Rust*** 自动为我们调用了一个特殊函数 `drop`，这就是 `String` 对象归还内存的位置；   
   ***Rust*** 在 `}` 处自动调用 `drop`，`drop` 是在 ***Prelude(前奏)*** 中的，可以直接调用。
   直接调用对 `&str` 使用不会有任何效果，对其他 栈 上存储的变量也是一样，但是出作用域一样会失效
6. 在 ***C++*** 中，在变量声明周期结束的时候归还内存有时被叫做 ***Resource Acquisition Is Initialization (RAII) 资源获取是初始化***，有点类似于 `drop` 
### 变量和数据交互的方式：Move
1. 一个 `String` 对象由三部分组成，指针(ptr)，长度(len in bytes) - bytes，容量(capacity in bytes) - bytes，这组数据被存在栈中，而实际指针指向的数据存在堆中。其他语言一般 `=` 时是将栈上的数据复制赋值了，意味着只有栈中 `String` 对象的 ptr、len、cap 被拷贝了，指向的还是同一个堆内存，浅拷贝，但 ***Rust*** 中有点不太一样。
2. 由于 `=` 后，两个变量指向同一个地址，因此在最后释放内存时，会产生 ***Double Free*** 错误。为了避免 double free 错误，***Rust*** 在 `let s2 = s1;` 后认为 `s1` 不再有效；所以浅拷贝对于 ***Rust*** 来说叫做 **move**，而不是 **copy**，moved 变量 不再有效可用，调用会产生编译错误。`let s2 = s1;` 在 ***Rust*** 中叫做：“ `s1` 被 move(移) 到了 `s2`”。但是以上是针对存在堆上的数据的，存在栈上的数据都实现了 `Copy` 特性，这时发生的是 copy，`let var1 = var2` 时具体是 move 还是 copy，取决于变量是实现了 `Drop` 特性，还是 `Copy` 特性(两个特性互斥)。
### 变量和数据交互的方式：Clone
如果需要深拷贝堆内存中的 `String`，而不是仅拷贝栈数据，使用方法 `clone`，例如：
```rust
let s1 = String::from("Hello");
let s2 = s1.clone();
println!("s1: {}; s2: {}", s1, s2);
```   
如果你看到了 `clone`，那么说明有些武断的代码被执行了，可能会很(性能&空间)昂贵，这是一个视觉指示器表示有些不同的事情发生。
### 仅在栈内存的数据：Copy
由于完全存储在栈内存上的数据(如整型数据)在编译时大小是已知的，因此这种值的拷贝非常快。由于仅在栈上，意味着创建新变量后没必要将旧变量失效，换句话说，深浅拷贝对于他们来说没有区别，调用 `clone` 和普通浅拷贝没有差异。   
如前面提到的，`let var1 = var2` 时具体是 move 还是 copy，取决于变量是实现了 `Drop` 特性，还是 `Copy` 特性(两个特性互斥)。你可以查文档看给定类型是否实现 `Copy`，一个通用的规则，一组简单的标量值可以是实现 `Copy`，和，不需要分配内存或一些类型的资源 可以实现 `Copy`，一些常见类型：
- 整型、布尔、浮点、字符
- 由实现了 `Copy` 元素组成的 元组

## 所有权和函数
将变量传入函数将会 move 或 copy，和赋值时发生的情况一样

## 返回值和域
返回值**可以**转化成 所有权


# (References)引用和(Borrowing)借用
***引用 - reference*** 像一个指针(pointer)，里面是一个可以访问 某个其他变量 的地址，不同于指针的是，reference 保证了其指向了一个 合法的确定类型的值
1. `&` - ampersands，代表 reference，可以使用格式 `&var_name`，来在不夺走 ownership 的条件下引用一些值，如果 `var_name` 类型为 `Type` 则其引用类型为 `&Type`
2. `*` - asterisk，代表 dereference，和引用完全相反的操作符号
3. 我们将创建引用的动作成为 ***Borrowing(借用)***。
4. 不仅堆内存中的数据可以借用，栈内存中的变量也是可以创建引用的
5. `&var_name` 让我们创造了一个 `var_name` 的引用，但是并不拥有它，由于不拥有它，因此当用完 `&var_name` 之后，堆中的变量内容并不会 dropped

## 可变引用
1. 引用默认是不可修改被借用变量的，想要修改需要：
   1. 被借用变量本身是 `mut`
   2. `fn func(variable: &mut Type) {}`  
   3. `func(&mut variable)`   
2. 可变引用有一个大限制：对于一个指定的数据，同一时间，**你只能拥有一个可变引用**，创建对同一变量的两个可变引用会导致编译失败。
3. 注意：**引用的生命周期持续到其被最后一次使用**，如果在最后一次使用可变引用前，再次创建引用，会导致编译失败；在最后一次使用后，则不会。这种能力叫做：***Non-Lexical Lifetimes***(NLL, 非词典生命周期)，查阅 [The Edition Guide](https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html) 了解更多   
4. 可变引用的限制保证了不会发生***数据竞争(data race)***，数据竞争会导致预期外的错误，并且在运行时很难诊断和追踪。在编译时，数据竞争(data race)当下列三种行为发生时 发生：
   - 两个或更多指针同时访问同一个数据；
   - 至少一个指针正在用于写入数据；
   - 没有任何机制用来同步数据访问；   
5. 我们始终可以通过 `{}` 来创建新的作用域，来进行多次创建可变引用，但是不要 同时 (暨一个还在生效的时候创建新的可变引用)
   ```rust    
   let mut s = String::from("hello");
      {
          let r1 = &mut s;
      } // r1 goes out of scope here, so we can make a new reference with no problems.
   let r2 = &mut s;
   ```
6. ***Rust*** 强制了类似的规则 对于组合 可变引用 和 不可变引用：**可以同时存在多个不可变引用，但是可变引用 不能 和不可变引用共存，且可变引用只能有一个**

## *Dangling References(悬挂引用)*
在拥有指针的语言中，很容易产生 **悬挂指针** 的错误，指：一个指针引用了一个内存位置，但是这个内存位置已经通过释放内存重新分派给其他数据了。在 ***Rust*** 中，编译器保证你的引用永远不会悬挂：如果你对某个数据有引用，编译器会保证这个数据不会在引用之前超出作用域。引用的作用域最远到接近 `}` 的最后一行代码(如果这代码使用了引用)，最近到最后一次使用的位置，而数据的作用域直到 `}` (如果创建了引用，则不能 **move**, 无论是新建变量，还是传入函数中)
1. 不要返回 **函数作用域中创建的数据 的引用**，因为数据仅在函数作用域中有效(无论是堆数据还是栈数据)。***Rust*** 不允许 *error[E0106]: missing lifetime specifier*
2. 如果一个 表达式 返回的是 `mut` 引用，接受它的变量不需要设定成 `mut`，也能通过解引用 `*` 来修改原变量。如：   
   ```rust
   let mut s = "Hello World".to_string();
   let s_mut_ref = &mut s;
   *s_mut_ref = "This worked!".to_string();
   ```

## 引用的规则
- 在任何时候，你可以有 一个可变引用(`&mut var`) 或者 任意数量的不可变引用(`&var`) 
- 引用必须总是有效的   


# Slice(切片) 类型
Slices 让你能够引用一个在集合中紧挨连续的元素，而不是整个集合。切片是一种引用，因此没有 ownership。   
如果使用 `word` 作为字符串 `let s = String::from("hello world")` 中第一个单词结束位置的索引，不论字符串怎么改变，如果不重新计算赋值给 `word`，那么 `word` 仍为 `5`，即使 `s` 已经为空了，由于不能保证 `word` 为目前的 `s` 的第一个单词的长度，会导致实际使用结果与预期不符；尤其的，如果使用这个值提取第一个单词，会导致 bug。如果不是从头/尾取 slice，会需要 begin 和 end 两个值，则需要同步的值增加到3个，非常麻烦易错。所以 ***Rust*** 提供了一个解决方案：String Slices(字符串切片)

## 字符串切片
***String Slice(字符串切片)*** 是字符串一部分的索引，格式：`let s_str = &a_string[starting_index..ending_index];`，索引惯例包左不包右，暨 ``ending_index``是最后一个位置索引 + 1 。
1. slice 数据结构内部，存储着 slice 的 **开始位置(ptr)** 和 slice 的 **长度(len)**，暨等于 `ending_index` - `starting_index`。
2. 如果 `starting_index` 是 `a_string` 的开始，或者 `ending_index` 是 `a_string` 的结束，则可以省略，如 `[..end_index]` 或 `[strat_index..]`，甚至可以同时省略： `&a_string[..]`，得到 `String` 类型值对应的 `&str` 类型值。
3. 注意，slice 引用 的类型为 `&str`，而不是 `&String`，所以虽然 `&a_str == &a_str[..]` 为 `true`，但是并不可以混淆，类型不同，包含的方法不同。个人认为，使用 `&a_str[..]` 语法的意义主要是匹配类型 `&str`。
4. 注意：字符串切片的范围索引必须发生在合法的 UTF-8 字符边界，如果试图在 多字节字符中间 创造一个 slice，会导致程序 error 退出。我们在 [[7-通用集合#^Storing-UTF8-Encoded-Text-with-Strings]] 中会更详细地讨论。
5. 字符串切片也相当于是 **该 `String` 的引用**，因此如果此引用作用域没结束(暨没到 `}` 并且后面仍有使用)，是不可以创建 `mut` 引用的，因为 Reference 的规则限制。***Rust*** 禁止 `s.clear()` 方法中的 **可变引用** 和 Slice 不可变引用同时存在，会导致编译失败。前面提到的不易调查修改的运行时的潜在错误，变成了编译错误。***Rust*** 不仅使我们的 API 更好用，还在编译时就消除了一系列错误。
### 字符串字面量 是 切片
字符串自面量是 Slices，这也是为什么字符串字面量是不可变的，`&str` 是不可变引用；Slice 可以设定为可变的，暨：`let mut a_slice = "Hello";` 是可以正常编译的，但是没什么用，因为没有什么改的 API 来修改这个变量，实际还是不可变的。
### 字符串字面量作为参数
有经验的 ***Rust*** 程序员会把 `fn first_word(s: &String) -> &str {}` 改写成 `fn first_word(s: &str) -> &str{}`，这样这个方程既可以用于 `&String` 也可以使用 `&str`：如果我们有个 slice，可以直接传入，如果是 `String`，可以传入其 slice 或者它的引用 - `&String`。   
这灵活性是受益于 ***deref coercions - 解引用强制多态***。我们在 [[13-智能指针#^Implicit-Deref-Coercions-with-Functions-and-Methods]] 会详细讲到。

## 其他切片
不仅 string 有 slice，数组也有 slice，一个由 `i32` 组成的数组，其 slice 的类型为 `&[i32]`


# 代码
- *Rust/ownership/src/main.rs*
